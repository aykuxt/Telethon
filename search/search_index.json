{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Telethon's Documentation \u00b6 from telethon.sync import TelegramClient , events with TelegramClient ( 'name' , api_id , api_hash ) as client : client . send_message ( 'me' , 'Hello, myself!' ) print ( client . download_profile_photo ( 'me' )) @client . on ( events . NewMessage ( pattern = '(?i).*Hello' )) async def handler ( event ): await event . reply ( 'Hey!' ) client . run_until_disconnected () Are you new here? Jump straight into Installation ! Looking for the method reference? See Client Reference . Did you upgrade the library? Please read Changelog (Version History) . Used Telethon before v1.0? See Compatibility and Convenience . Coming from Bot API or want to create new bots? See HTTP Bot API vs MTProto . Need the full API reference? https://tl.telethon.dev . What is this? \u00b6 Telegram is a popular messaging application. This library is meant to make it easy for you to write Python programs that can interact with Telegram. Think of it as a wrapper that has already done the heavy job for you, so you can focus on developing an application. How should I use the documentation? \u00b6 If you are getting started with the library, you should follow the documentation in order by pressing the \"Next\" button at the bottom-right of every page. You can also use the menu on the left to quickly skip over sections.","title":"Getting started"},{"location":"#telethons-documentation","text":"from telethon.sync import TelegramClient , events with TelegramClient ( 'name' , api_id , api_hash ) as client : client . send_message ( 'me' , 'Hello, myself!' ) print ( client . download_profile_photo ( 'me' )) @client . on ( events . NewMessage ( pattern = '(?i).*Hello' )) async def handler ( event ): await event . reply ( 'Hey!' ) client . run_until_disconnected () Are you new here? Jump straight into Installation ! Looking for the method reference? See Client Reference . Did you upgrade the library? Please read Changelog (Version History) . Used Telethon before v1.0? See Compatibility and Convenience . Coming from Bot API or want to create new bots? See HTTP Bot API vs MTProto . Need the full API reference? https://tl.telethon.dev .","title":"Telethon's Documentation"},{"location":"#what-is-this","text":"Telegram is a popular messaging application. This library is meant to make it easy for you to write Python programs that can interact with Telegram. Think of it as a wrapper that has already done the heavy job for you, so you can focus on developing an application.","title":"What is this?"},{"location":"#how-should-i-use-the-documentation","text":"If you are getting started with the library, you should follow the documentation in order by pressing the \"Next\" button at the bottom-right of every page. You can also use the menu on the left to quickly skip over sections.","title":"How should I use the documentation?"},{"location":"basic/installation/","text":"Installation \u00b6 Telethon is a Python library, which means you need to download and install Python from https://www.python.org/downloads/ if you haven't already. Once you have Python installed, run: pip3 install -U telethon --user To install or upgrade the library to the latest version. Installing Development Versions \u00b6 If you want the latest unreleased changes, you can run the following command instead: pip3 install -U https://github.com/LonamiWebs/Telethon/archive/master.zip --user Note The development version may have bugs and is not recommended for production use. However, when you are reporting a library bug , you should try if the bug still occurs in this version. Verification \u00b6 To verify that the library is installed correctly, run the following command: python3 -c \"import telethon; print(telethon.__version__)\" The version number of the library should show in the output. Optional Dependencies \u00b6 If cryptg is installed, the library will work a lot faster , since encryption and decryption will be made in C instead of Python. If your code deals with a lot of updates or you are downloading/uploading a lot of files, you will notice a considerable speed-up (from a hundred kilobytes per second to several megabytes per second, if your connection allows it). If it's not installed, pyaes will be used (which is pure Python, so it's much slower). If pillow is installed, large images will be automatically resized when sending photos to prevent Telegram from failing with \"invalid image\". Official clients also do this. If aiohttp is installed, the library will be able to download :tl: WebDocument media files (otherwise you will get an error). If hachoir is installed, it will be used to extract metadata from files when sending documents. Telegram uses this information to show the song's performer, artist, title, duration, and for videos too (including size). Otherwise, they will default to empty values, and you can set the attributes manually. Note Some of the modules may require additional dependencies before being installed through pip . If you have an apt -based system, consider installing the most commonly missing dependencies: apt update apt install clang lib { jpeg-turbo,webp } -dev python { ,-dev } zlib-dev pip install -U --user setuptools pip install -U --user telethon cryptg pillow Thanks to @bb010g for writing down this nice list.","title":"Installation"},{"location":"basic/installation/#installation","text":"Telethon is a Python library, which means you need to download and install Python from https://www.python.org/downloads/ if you haven't already. Once you have Python installed, run: pip3 install -U telethon --user To install or upgrade the library to the latest version.","title":"Installation"},{"location":"basic/installation/#installing-development-versions","text":"If you want the latest unreleased changes, you can run the following command instead: pip3 install -U https://github.com/LonamiWebs/Telethon/archive/master.zip --user Note The development version may have bugs and is not recommended for production use. However, when you are reporting a library bug , you should try if the bug still occurs in this version.","title":"Installing Development Versions"},{"location":"basic/installation/#verification","text":"To verify that the library is installed correctly, run the following command: python3 -c \"import telethon; print(telethon.__version__)\" The version number of the library should show in the output.","title":"Verification"},{"location":"basic/installation/#optional-dependencies","text":"If cryptg is installed, the library will work a lot faster , since encryption and decryption will be made in C instead of Python. If your code deals with a lot of updates or you are downloading/uploading a lot of files, you will notice a considerable speed-up (from a hundred kilobytes per second to several megabytes per second, if your connection allows it). If it's not installed, pyaes will be used (which is pure Python, so it's much slower). If pillow is installed, large images will be automatically resized when sending photos to prevent Telegram from failing with \"invalid image\". Official clients also do this. If aiohttp is installed, the library will be able to download :tl: WebDocument media files (otherwise you will get an error). If hachoir is installed, it will be used to extract metadata from files when sending documents. Telegram uses this information to show the song's performer, artist, title, duration, and for videos too (including size). Otherwise, they will default to empty values, and you can set the attributes manually. Note Some of the modules may require additional dependencies before being installed through pip . If you have an apt -based system, consider installing the most commonly missing dependencies: apt update apt install clang lib { jpeg-turbo,webp } -dev python { ,-dev } zlib-dev pip install -U --user setuptools pip install -U --user telethon cryptg pillow Thanks to @bb010g for writing down this nice list.","title":"Optional Dependencies"},{"location":"basic/next-steps/","text":"Next Steps \u00b6 These basic first steps should have gotten you started with the library. By now, you should know how to call friendly methods and how to work with the returned objects, how things work inside event handlers, etc. Next, we will see a quick reference summary of all the methods and properties that you will need when using the library. If you follow the links there, you will expand the documentation for the method and property, with more examples on how to use them. Therefore, you can find an example on every method of the client to learn how to use it, as well as a description of all the arguments. After that, we will go in-depth with some other important concepts that are worth learning and understanding. From now on, you can keep pressing the \"Next\" button if you want, or use the menu on the left, since some pages are quite lengthy.","title":"Next Steps"},{"location":"basic/next-steps/#next-steps","text":"These basic first steps should have gotten you started with the library. By now, you should know how to call friendly methods and how to work with the returned objects, how things work inside event handlers, etc. Next, we will see a quick reference summary of all the methods and properties that you will need when using the library. If you follow the links there, you will expand the documentation for the method and property, with more examples on how to use them. Therefore, you can find an example on every method of the client to learn how to use it, as well as a description of all the arguments. After that, we will go in-depth with some other important concepts that are worth learning and understanding. From now on, you can keep pressing the \"Next\" button if you want, or use the menu on the left, since some pages are quite lengthy.","title":"Next Steps"},{"location":"basic/quick-start/","text":"Quick-Start \u00b6 Let's see a longer example to learn some of the methods that the library has to offer. These are known as \"friendly methods\", and you should always use these if possible. from telethon import TelegramClient # Remember to use your own values from my.telegram.org! api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' client = TelegramClient ( 'anon' , api_id , api_hash ) async def main (): # Getting information about yourself me = await client . get_me () # \"me\" is an User object. You can pretty-print # any Telegram object with the \"stringify\" method: print ( me . stringify ()) # When you print something, you see a representation of it. # You can access all attributes of Telegram objects with # the dot operator. For example, to get the username: username = me . username print ( username ) print ( me . phone ) # You can print all the dialogs/conversations that you are part of: async for dialog in client . iter_dialogs (): print ( dialog . name , 'has ID' , dialog . id ) # You can send messages to yourself... await client . send_message ( 'me' , 'Hello, myself!' ) # ...to some chat ID await client . send_message ( - 100123456 , 'Hello, group!' ) # ...to your contacts await client . send_message ( '+34600123123' , 'Hello, friend!' ) # ...or even to any username await client . send_message ( 'TelethonChat' , 'Hello, Telethon!' ) # You can, of course, use markdown in your messages: message = await client . send_message ( 'me' , 'This message has **bold**, `code`, __italics__ and ' 'a [nice website](https://example.com)!' , link_preview = False ) # Sending a message returns the sent message object, which you can use print ( message . raw_text ) # You can reply to messages directly if you have a message object await message . reply ( 'Cool!' ) # Or send files, songs, documents, albums... await client . send_file ( 'me' , '/home/me/Pictures/holidays.jpg' ) # You can print the message history of any chat: async for message in client . iter_messages ( 'me' ): print ( message . id , message . text ) # You can download media from messages, too! # The method will return the path where the file was saved. if message . photo : path = await message . download_media () print ( 'File saved to' , path ) # printed after download is done with client : client . loop . run_until_complete ( main ()) Here, we show how to sign in, get information about yourself, send messages, files, getting chats, printing messages, and downloading files. You should make sure that you understand what the code shown here does, take note on how methods are called and used and so on before proceeding. We will see all the available methods later on. Important Note that Telethon is an asynchronous library, and as such, you should get used to it and learn a bit of basic asyncio . This will help a lot. As a quick start, this means you generally want to write all your code inside some async def like so: client = ... async def do_something ( me ): ... async def main (): # Most of your code should go here. # You can of course make and use your own async def (do_something). # They only need to be async if they need to await things. me = await client . get_me () await do_something ( me ) with client : client . loop . run_until_complete ( main ()) After you understand this, you may use the telethon.sync hack if you want do so (see :ref: compatibility-and-convenience ), but note you may run into other issues (iPython, Anaconda, etc. have some issues with it).","title":"Quick-Start"},{"location":"basic/quick-start/#quick-start","text":"Let's see a longer example to learn some of the methods that the library has to offer. These are known as \"friendly methods\", and you should always use these if possible. from telethon import TelegramClient # Remember to use your own values from my.telegram.org! api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' client = TelegramClient ( 'anon' , api_id , api_hash ) async def main (): # Getting information about yourself me = await client . get_me () # \"me\" is an User object. You can pretty-print # any Telegram object with the \"stringify\" method: print ( me . stringify ()) # When you print something, you see a representation of it. # You can access all attributes of Telegram objects with # the dot operator. For example, to get the username: username = me . username print ( username ) print ( me . phone ) # You can print all the dialogs/conversations that you are part of: async for dialog in client . iter_dialogs (): print ( dialog . name , 'has ID' , dialog . id ) # You can send messages to yourself... await client . send_message ( 'me' , 'Hello, myself!' ) # ...to some chat ID await client . send_message ( - 100123456 , 'Hello, group!' ) # ...to your contacts await client . send_message ( '+34600123123' , 'Hello, friend!' ) # ...or even to any username await client . send_message ( 'TelethonChat' , 'Hello, Telethon!' ) # You can, of course, use markdown in your messages: message = await client . send_message ( 'me' , 'This message has **bold**, `code`, __italics__ and ' 'a [nice website](https://example.com)!' , link_preview = False ) # Sending a message returns the sent message object, which you can use print ( message . raw_text ) # You can reply to messages directly if you have a message object await message . reply ( 'Cool!' ) # Or send files, songs, documents, albums... await client . send_file ( 'me' , '/home/me/Pictures/holidays.jpg' ) # You can print the message history of any chat: async for message in client . iter_messages ( 'me' ): print ( message . id , message . text ) # You can download media from messages, too! # The method will return the path where the file was saved. if message . photo : path = await message . download_media () print ( 'File saved to' , path ) # printed after download is done with client : client . loop . run_until_complete ( main ()) Here, we show how to sign in, get information about yourself, send messages, files, getting chats, printing messages, and downloading files. You should make sure that you understand what the code shown here does, take note on how methods are called and used and so on before proceeding. We will see all the available methods later on. Important Note that Telethon is an asynchronous library, and as such, you should get used to it and learn a bit of basic asyncio . This will help a lot. As a quick start, this means you generally want to write all your code inside some async def like so: client = ... async def do_something ( me ): ... async def main (): # Most of your code should go here. # You can of course make and use your own async def (do_something). # They only need to be async if they need to await things. me = await client . get_me () await do_something ( me ) with client : client . loop . run_until_complete ( main ()) After you understand this, you may use the telethon.sync hack if you want do so (see :ref: compatibility-and-convenience ), but note you may run into other issues (iPython, Anaconda, etc. have some issues with it).","title":"Quick-Start"},{"location":"basic/signing-in/","text":"Signing In \u00b6 Before working with Telegram's API, you need to get your own API ID and hash: Login to your Telegram account with the phone number of the developer account to use. Click under API Development tools. A Create new application window will appear. Fill in your application details. There is no need to enter any URL , and only the first two fields ( App title and Short name ) can currently be changed later. Click on Create application at the end. Remember that your API hash is secret and Telegram won't let you revoke it. Don't post it anywhere! Note This API ID and hash is the one used by your application , not your phone number. You can use this API ID and hash with any phone number or even for bot accounts. Editing the Code \u00b6 This is a little introduction for those new to Python programming in general. We will write our code inside hello.py , so you can use any text editor that you like. To run the code, use python3 hello.py from the terminal. Important Don't call your script telethon.py ! Python will try to import the client from there and it will fail with an error such as ImportError: cannot import name 'TelegramClient' ... . Signing In \u00b6 We can finally write some code to log into our account! from telethon import TelegramClient # Use your own values from my.telegram.org api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' # The first parameter is the .session file name (absolute paths allowed) with TelegramClient ( 'anon' , api_id , api_hash ) as client : client . loop . run_until_complete ( client . send_message ( 'me' , 'Hello, myself!' )) In the first line, we import the class name so we can create an instance of the client. Then, we define variables to store our API ID and hash conveniently. At last, we create a new TelegramClient <telethon.client.telegramclient.TelegramClient> instance and call it client . We can now use the client variable for anything that we want, such as sending a message to ourselves. Note Since Telethon is an asynchronous library, you need to await coroutine functions to have them run (or otherwise, run the loop until they are complete). In this tiny example, we don't bother making an async def main() . See :ref: mastering-asyncio to find out more. Using a with block is the preferred way to use the library. It will automatically start() <telethon.client.auth.AuthMethods.start> the client, logging or signing up if necessary. If the .session file already existed, it will not login again, so be aware of this if you move or rename the file! Signing In as a Bot Account \u00b6 You can also use Telethon for your bots (normal bot accounts, not users). You will still need an API ID and hash, but the process is very similar: from telethon.sync import TelegramClient api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' bot_token = '12345:0123456789abcdef0123456789abcdef' # We have to manually call \"start\" if we want an explicit bot token bot = TelegramClient ( 'bot' , api_id , api_hash ) . start ( bot_token = bot_token ) # But then we can use the client instance as usual with bot : ... To get a bot account, you need to talk with @BotFather <https://t.me/BotFather> _. Signing In behind a Proxy \u00b6 If you need to use a proxy to access Telegram, you will need to install PySocks and then change: TelegramClient ( 'anon' , api_id , api_hash ) with TelegramClient ( 'anon' , api_id , api_hash , proxy = ( socks . SOCKS5 , '127.0.0.1' , 4444 )) (of course, replacing the IP and port with the IP and port of the proxy). The proxy= argument should be a tuple, a list or a dict, consisting of parameters described in PySocks usage . Using MTProto Proxies \u00b6 MTProto Proxies are Telegram's alternative to normal proxies, and work a bit differently. The following protocols are available: ConnectionTcpMTProxyAbridged ConnectionTcpMTProxyIntermediate ConnectionTcpMTProxyRandomizedIntermediate (preferred) For now, you need to manually specify these special connection modes if you want to use a MTProto Proxy. Your code would look like this: from telethon import TelegramClient , connection # we need to change the connection ^^^^^^^^^^ client = TelegramClient ( 'anon' , api_id , api_hash , # Use one of the available connection modes. # Normally, this one works with most proxies. connection = connection . ConnectionTcpMTProxyRandomizedIntermediate , # Then, pass the proxy details as a tuple: # (host name, port, proxy secret) # # If the proxy has no secret, the secret must be: # '00000000000000000000000000000000' proxy = ( 'mtproxy.example.com' , 2002 , 'secret' ) ) In future updates, we may make it easier to use MTProto Proxies (such as avoiding the need to manually pass connection= ). In short, the same code above but without comments to make it clearer: from telethon import TelegramClient , connection client = TelegramClient ( 'anon' , api_id , api_hash , connection = connection . ConnectionTcpMTProxyRandomizedIntermediate , proxy = ( 'mtproxy.example.com' , 2002 , 'secret' ) )","title":"Signing In"},{"location":"basic/signing-in/#signing-in","text":"Before working with Telegram's API, you need to get your own API ID and hash: Login to your Telegram account with the phone number of the developer account to use. Click under API Development tools. A Create new application window will appear. Fill in your application details. There is no need to enter any URL , and only the first two fields ( App title and Short name ) can currently be changed later. Click on Create application at the end. Remember that your API hash is secret and Telegram won't let you revoke it. Don't post it anywhere! Note This API ID and hash is the one used by your application , not your phone number. You can use this API ID and hash with any phone number or even for bot accounts.","title":"Signing In"},{"location":"basic/signing-in/#editing-the-code","text":"This is a little introduction for those new to Python programming in general. We will write our code inside hello.py , so you can use any text editor that you like. To run the code, use python3 hello.py from the terminal. Important Don't call your script telethon.py ! Python will try to import the client from there and it will fail with an error such as ImportError: cannot import name 'TelegramClient' ... .","title":"Editing the Code"},{"location":"basic/signing-in/#signing-in_1","text":"We can finally write some code to log into our account! from telethon import TelegramClient # Use your own values from my.telegram.org api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' # The first parameter is the .session file name (absolute paths allowed) with TelegramClient ( 'anon' , api_id , api_hash ) as client : client . loop . run_until_complete ( client . send_message ( 'me' , 'Hello, myself!' )) In the first line, we import the class name so we can create an instance of the client. Then, we define variables to store our API ID and hash conveniently. At last, we create a new TelegramClient <telethon.client.telegramclient.TelegramClient> instance and call it client . We can now use the client variable for anything that we want, such as sending a message to ourselves. Note Since Telethon is an asynchronous library, you need to await coroutine functions to have them run (or otherwise, run the loop until they are complete). In this tiny example, we don't bother making an async def main() . See :ref: mastering-asyncio to find out more. Using a with block is the preferred way to use the library. It will automatically start() <telethon.client.auth.AuthMethods.start> the client, logging or signing up if necessary. If the .session file already existed, it will not login again, so be aware of this if you move or rename the file!","title":"Signing In"},{"location":"basic/signing-in/#signing-in-as-a-bot-account","text":"You can also use Telethon for your bots (normal bot accounts, not users). You will still need an API ID and hash, but the process is very similar: from telethon.sync import TelegramClient api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' bot_token = '12345:0123456789abcdef0123456789abcdef' # We have to manually call \"start\" if we want an explicit bot token bot = TelegramClient ( 'bot' , api_id , api_hash ) . start ( bot_token = bot_token ) # But then we can use the client instance as usual with bot : ... To get a bot account, you need to talk with @BotFather <https://t.me/BotFather> _.","title":"Signing In as a Bot Account"},{"location":"basic/signing-in/#signing-in-behind-a-proxy","text":"If you need to use a proxy to access Telegram, you will need to install PySocks and then change: TelegramClient ( 'anon' , api_id , api_hash ) with TelegramClient ( 'anon' , api_id , api_hash , proxy = ( socks . SOCKS5 , '127.0.0.1' , 4444 )) (of course, replacing the IP and port with the IP and port of the proxy). The proxy= argument should be a tuple, a list or a dict, consisting of parameters described in PySocks usage .","title":"Signing In behind a Proxy"},{"location":"basic/signing-in/#using-mtproto-proxies","text":"MTProto Proxies are Telegram's alternative to normal proxies, and work a bit differently. The following protocols are available: ConnectionTcpMTProxyAbridged ConnectionTcpMTProxyIntermediate ConnectionTcpMTProxyRandomizedIntermediate (preferred) For now, you need to manually specify these special connection modes if you want to use a MTProto Proxy. Your code would look like this: from telethon import TelegramClient , connection # we need to change the connection ^^^^^^^^^^ client = TelegramClient ( 'anon' , api_id , api_hash , # Use one of the available connection modes. # Normally, this one works with most proxies. connection = connection . ConnectionTcpMTProxyRandomizedIntermediate , # Then, pass the proxy details as a tuple: # (host name, port, proxy secret) # # If the proxy has no secret, the secret must be: # '00000000000000000000000000000000' proxy = ( 'mtproxy.example.com' , 2002 , 'secret' ) ) In future updates, we may make it easier to use MTProto Proxies (such as avoiding the need to manually pass connection= ). In short, the same code above but without comments to make it clearer: from telethon import TelegramClient , connection client = TelegramClient ( 'anon' , api_id , api_hash , connection = connection . ConnectionTcpMTProxyRandomizedIntermediate , proxy = ( 'mtproxy.example.com' , 2002 , 'secret' ) )","title":"Using MTProto Proxies"},{"location":"basic/updates/","text":"Updates \u00b6 Updates are an important topic in a messaging platform like Telegram. After all, you want to be notified when a new message arrives, when a member joins, when someone starts typing, etc. For that, you can use events . Important It is strongly advised to enable logging when working with events, since exceptions in event handlers are hidden by default. Please add the following snippet to the very top of your file: import logging logging . basicConfig ( format = '[ %(levelname) 5s / %(asctime)s ] %(name)s : %(message)s ' , level = logging . WARNING ) Getting Started \u00b6 Let's start things with an example to automate replies: from telethon import TelegramClient , events client = TelegramClient ( 'anon' , api_id , api_hash ) @client . on ( events . NewMessage ) async def my_event_handler ( event ): if 'hello' in event . raw_text : await event . reply ( 'hi!' ) client . start () client . run_until_disconnected () This code isn't much, but there might be some things unclear. Let's break it down: from telethon import TelegramClient , events client = TelegramClient ( 'anon' , api_id , api_hash ) This is normal creation (of course, pass session name, API ID and hash). Nothing we don't know already. @client . on ( events . NewMessage ) This Python decorator will attach itself to the my_event_handler definition, and basically means that on a NewMessage <telethon.events.newmessage.NewMessage> event , the callback function you're about to define will be called: async def my_event_handler ( event ): if 'hello' in event . raw_text : await event . reply ( 'hi!' ) If a NewMessage <telethon.events.newmessage.NewMessage> event occurs, and 'hello' is in the text of the message, we reply() <telethon.tl.custom.message.Message.reply> to the event with a 'hi!' message. Note Event handlers must be async def . After all, Telethon is an asynchronous library based on asyncio , which is a safer and often faster approach to threads. You must await all method calls that use network requests, which is most of them. More Examples \u00b6 Replying to messages with hello is fun, but, can we do more? @client . on ( events . NewMessage ( outgoing = True , pattern = r '\\.save' )) async def handler ( event ): if event . is_reply : replied = await event . get_reply_message () sender = replied . sender await client . download_profile_photo ( sender ) await event . respond ( 'Saved your photo {} ' . format ( sender . username )) We could also get replies. This event filters outgoing messages (only those that we send will trigger the method), then we filter by the regex r'\\.save' , which will match messages starting with \".save\" . Inside the method, we check whether the event is replying to another message or not. If it is, we get the reply message and the sender of that message, and download their profile photo. Let's delete messages which contain \"heck\". We don't allow swearing here. @client . on ( events . NewMessage ( pattern = r '(?i).*heck' )) async def handler ( event ): await event . delete () With the r'(?i).*heck' regex, we match case-insensitive \"heck\" anywhere in the message. Regex is very powerful and you can learn more at https://regexone.com/. So far, we have only seen the NewMessage <telethon.events.newmessage.NewMessage> , but there are many more which will be covered later. This is only a small introduction to updates. Entities \u00b6 When you need the user or chat where an event occurred, you must use the following methods: async def handler ( event ): # Good chat = await event . get_chat () sender = await event . get_sender () chat_id = event . chat_id sender_id = event . sender_id # BAD. Don't do this chat = event . chat sender = event . sender chat_id = event . chat . id sender_id = event . sender . id Events are like messages, but don't have all the information a message has! When you manually get a message, it will have all the information it needs. When you receive an update about a message, it won't have all the information, so you have to use the methods , not the properties. Make sure you understand the code seen here before continuing! As a rule of thumb, remember that new message events behave just like message objects, so you can do with them everything you can do with a message object.","title":"Updates"},{"location":"basic/updates/#updates","text":"Updates are an important topic in a messaging platform like Telegram. After all, you want to be notified when a new message arrives, when a member joins, when someone starts typing, etc. For that, you can use events . Important It is strongly advised to enable logging when working with events, since exceptions in event handlers are hidden by default. Please add the following snippet to the very top of your file: import logging logging . basicConfig ( format = '[ %(levelname) 5s / %(asctime)s ] %(name)s : %(message)s ' , level = logging . WARNING )","title":"Updates"},{"location":"basic/updates/#getting-started","text":"Let's start things with an example to automate replies: from telethon import TelegramClient , events client = TelegramClient ( 'anon' , api_id , api_hash ) @client . on ( events . NewMessage ) async def my_event_handler ( event ): if 'hello' in event . raw_text : await event . reply ( 'hi!' ) client . start () client . run_until_disconnected () This code isn't much, but there might be some things unclear. Let's break it down: from telethon import TelegramClient , events client = TelegramClient ( 'anon' , api_id , api_hash ) This is normal creation (of course, pass session name, API ID and hash). Nothing we don't know already. @client . on ( events . NewMessage ) This Python decorator will attach itself to the my_event_handler definition, and basically means that on a NewMessage <telethon.events.newmessage.NewMessage> event , the callback function you're about to define will be called: async def my_event_handler ( event ): if 'hello' in event . raw_text : await event . reply ( 'hi!' ) If a NewMessage <telethon.events.newmessage.NewMessage> event occurs, and 'hello' is in the text of the message, we reply() <telethon.tl.custom.message.Message.reply> to the event with a 'hi!' message. Note Event handlers must be async def . After all, Telethon is an asynchronous library based on asyncio , which is a safer and often faster approach to threads. You must await all method calls that use network requests, which is most of them.","title":"Getting Started"},{"location":"basic/updates/#more-examples","text":"Replying to messages with hello is fun, but, can we do more? @client . on ( events . NewMessage ( outgoing = True , pattern = r '\\.save' )) async def handler ( event ): if event . is_reply : replied = await event . get_reply_message () sender = replied . sender await client . download_profile_photo ( sender ) await event . respond ( 'Saved your photo {} ' . format ( sender . username )) We could also get replies. This event filters outgoing messages (only those that we send will trigger the method), then we filter by the regex r'\\.save' , which will match messages starting with \".save\" . Inside the method, we check whether the event is replying to another message or not. If it is, we get the reply message and the sender of that message, and download their profile photo. Let's delete messages which contain \"heck\". We don't allow swearing here. @client . on ( events . NewMessage ( pattern = r '(?i).*heck' )) async def handler ( event ): await event . delete () With the r'(?i).*heck' regex, we match case-insensitive \"heck\" anywhere in the message. Regex is very powerful and you can learn more at https://regexone.com/. So far, we have only seen the NewMessage <telethon.events.newmessage.NewMessage> , but there are many more which will be covered later. This is only a small introduction to updates.","title":"More Examples"},{"location":"basic/updates/#entities","text":"When you need the user or chat where an event occurred, you must use the following methods: async def handler ( event ): # Good chat = await event . get_chat () sender = await event . get_sender () chat_id = event . chat_id sender_id = event . sender_id # BAD. Don't do this chat = event . chat sender = event . sender chat_id = event . chat . id sender_id = event . sender . id Events are like messages, but don't have all the information a message has! When you manually get a message, it will have all the information it needs. When you receive an update about a message, it won't have all the information, so you have to use the methods , not the properties. Make sure you understand the code seen here before continuing! As a rule of thumb, remember that new message events behave just like message objects, so you can do with them everything you can do with a message object.","title":"Entities"},{"location":"modules/helpers/","text":"\u00b6 Various helpers not related to the Telegram API itself TotalList \u00b6 A list with an extra total property, which may not match its len since the total represents the total amount of items available somewhere else, not the items in this list . Examples: # Telethon returns these lists in some cases (for example, # only when a chunk is returned, but the \"total\" count # is available). result = await client . get_messages ( chat , limit = 10 ) print ( result . total ) # large number print ( len ( result )) # 10 print ( result [ 0 ]) # latest message for x in result : # show the 10 messages print ( x . text ) ensure_parent_dir_exists ( file_path ) \u00b6 Ensures that the parent directory exists Source code in telethon\\helpers.py 23 24 25 26 27 def ensure_parent_dir_exists ( file_path ): \"\"\"Ensures that the parent directory exists\"\"\" parent = os . path . dirname ( file_path ) if parent : os . makedirs ( parent , exist_ok = True ) generate_key_data_from_nonce ( server_nonce , new_nonce ) \u00b6 Generates the key data corresponding to the given nonce Source code in telethon\\helpers.py 207 208 209 210 211 212 213 214 215 216 217 def generate_key_data_from_nonce ( server_nonce , new_nonce ): \"\"\"Generates the key data corresponding to the given nonce\"\"\" server_nonce = server_nonce . to_bytes ( 16 , 'little' , signed = True ) new_nonce = new_nonce . to_bytes ( 32 , 'little' , signed = True ) hash1 = sha1 ( new_nonce + server_nonce ) . digest () hash2 = sha1 ( server_nonce + new_nonce ) . digest () hash3 = sha1 ( new_nonce + new_nonce ) . digest () key = hash1 + hash2 [: 12 ] iv = hash2 [ 12 : 20 ] + hash3 + new_nonce [: 4 ] return key , iv generate_random_long ( signed = True ) \u00b6 Generates a random long integer (8 bytes), which is optionally signed Source code in telethon\\helpers.py 18 19 20 def generate_random_long ( signed = True ): \"\"\"Generates a random long integer (8 bytes), which is optionally signed\"\"\" return int . from_bytes ( os . urandom ( 8 ), signed = signed , byteorder = 'little' ) retry_range ( retries ) \u00b6 Generates an integer sequence starting from 1. If retries is not a zero or a positive integer value, the sequence will be infinite, otherwise it will end at retries + 1 . Source code in telethon\\helpers.py 97 98 99 100 101 102 103 104 105 106 107 def retry_range ( retries ): \"\"\" Generates an integer sequence starting from 1. If `retries` is not a zero or a positive integer value, the sequence will be infinite, otherwise it will end at `retries + 1`. \"\"\" yield 1 attempt = 0 while attempt != retries : attempt += 1 yield 1 + attempt strip_text ( text , entities ) \u00b6 Strips whitespace from the given text modifying the provided entities. This assumes that there are no overlapping entities, that their length is greater or equal to one, and that their length is not out of bounds. Source code in telethon\\helpers.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def strip_text ( text , entities ): \"\"\" Strips whitespace from the given text modifying the provided entities. This assumes that there are no overlapping entities, that their length is greater or equal to one, and that their length is not out of bounds. \"\"\" if not entities : return text . strip () while text and text [ - 1 ] . isspace (): e = entities [ - 1 ] if e . offset + e . length == len ( text ): if e . length == 1 : del entities [ - 1 ] if not entities : return text . strip () else : e . length -= 1 text = text [: - 1 ] while text and text [ 0 ] . isspace (): for i in reversed ( range ( len ( entities ))): e = entities [ i ] if e . offset != 0 : e . offset -= 1 continue if e . length == 1 : del entities [ 0 ] if not entities : return text . lstrip () else : e . length -= 1 text = text [ 1 :] return text within_surrogate ( text , index , * , length = None ) \u00b6 True if index is within a surrogate (before and after it, not at!). Source code in telethon\\helpers.py 43 44 45 46 47 48 49 50 51 52 53 54 def within_surrogate ( text , index , * , length = None ): \"\"\" `True` if ``index`` is within a surrogate (before and after it, not at!). \"\"\" if length is None : length = len ( text ) return ( 1 < index < len ( text ) and # in bounds ' \\ud800 ' <= text [ index - 1 ] <= ' \\udfff ' and # previous is ' \\ud800 ' <= text [ index ] <= ' \\udfff ' # current is )","title":"Helpers"},{"location":"modules/helpers/#telethon.helpers","text":"Various helpers not related to the Telegram API itself","title":"telethon.helpers"},{"location":"modules/helpers/#telethon.helpers.TotalList","text":"A list with an extra total property, which may not match its len since the total represents the total amount of items available somewhere else, not the items in this list . Examples: # Telethon returns these lists in some cases (for example, # only when a chunk is returned, but the \"total\" count # is available). result = await client . get_messages ( chat , limit = 10 ) print ( result . total ) # large number print ( len ( result )) # 10 print ( result [ 0 ]) # latest message for x in result : # show the 10 messages print ( x . text )","title":"TotalList"},{"location":"modules/helpers/#telethon.helpers.ensure_parent_dir_exists","text":"Ensures that the parent directory exists Source code in telethon\\helpers.py 23 24 25 26 27 def ensure_parent_dir_exists ( file_path ): \"\"\"Ensures that the parent directory exists\"\"\" parent = os . path . dirname ( file_path ) if parent : os . makedirs ( parent , exist_ok = True )","title":"ensure_parent_dir_exists()"},{"location":"modules/helpers/#telethon.helpers.generate_key_data_from_nonce","text":"Generates the key data corresponding to the given nonce Source code in telethon\\helpers.py 207 208 209 210 211 212 213 214 215 216 217 def generate_key_data_from_nonce ( server_nonce , new_nonce ): \"\"\"Generates the key data corresponding to the given nonce\"\"\" server_nonce = server_nonce . to_bytes ( 16 , 'little' , signed = True ) new_nonce = new_nonce . to_bytes ( 32 , 'little' , signed = True ) hash1 = sha1 ( new_nonce + server_nonce ) . digest () hash2 = sha1 ( server_nonce + new_nonce ) . digest () hash3 = sha1 ( new_nonce + new_nonce ) . digest () key = hash1 + hash2 [: 12 ] iv = hash2 [ 12 : 20 ] + hash3 + new_nonce [: 4 ] return key , iv","title":"generate_key_data_from_nonce()"},{"location":"modules/helpers/#telethon.helpers.generate_random_long","text":"Generates a random long integer (8 bytes), which is optionally signed Source code in telethon\\helpers.py 18 19 20 def generate_random_long ( signed = True ): \"\"\"Generates a random long integer (8 bytes), which is optionally signed\"\"\" return int . from_bytes ( os . urandom ( 8 ), signed = signed , byteorder = 'little' )","title":"generate_random_long()"},{"location":"modules/helpers/#telethon.helpers.retry_range","text":"Generates an integer sequence starting from 1. If retries is not a zero or a positive integer value, the sequence will be infinite, otherwise it will end at retries + 1 . Source code in telethon\\helpers.py 97 98 99 100 101 102 103 104 105 106 107 def retry_range ( retries ): \"\"\" Generates an integer sequence starting from 1. If `retries` is not a zero or a positive integer value, the sequence will be infinite, otherwise it will end at `retries + 1`. \"\"\" yield 1 attempt = 0 while attempt != retries : attempt += 1 yield 1 + attempt","title":"retry_range()"},{"location":"modules/helpers/#telethon.helpers.strip_text","text":"Strips whitespace from the given text modifying the provided entities. This assumes that there are no overlapping entities, that their length is greater or equal to one, and that their length is not out of bounds. Source code in telethon\\helpers.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def strip_text ( text , entities ): \"\"\" Strips whitespace from the given text modifying the provided entities. This assumes that there are no overlapping entities, that their length is greater or equal to one, and that their length is not out of bounds. \"\"\" if not entities : return text . strip () while text and text [ - 1 ] . isspace (): e = entities [ - 1 ] if e . offset + e . length == len ( text ): if e . length == 1 : del entities [ - 1 ] if not entities : return text . strip () else : e . length -= 1 text = text [: - 1 ] while text and text [ 0 ] . isspace (): for i in reversed ( range ( len ( entities ))): e = entities [ i ] if e . offset != 0 : e . offset -= 1 continue if e . length == 1 : del entities [ 0 ] if not entities : return text . lstrip () else : e . length -= 1 text = text [ 1 :] return text","title":"strip_text()"},{"location":"modules/helpers/#telethon.helpers.within_surrogate","text":"True if index is within a surrogate (before and after it, not at!). Source code in telethon\\helpers.py 43 44 45 46 47 48 49 50 51 52 53 54 def within_surrogate ( text , index , * , length = None ): \"\"\" `True` if ``index`` is within a surrogate (before and after it, not at!). \"\"\" if length is None : length = len ( text ) return ( 1 < index < len ( text ) and # in bounds ' \\ud800 ' <= text [ index - 1 ] <= ' \\udfff ' and # previous is ' \\ud800 ' <= text [ index ] <= ' \\udfff ' # current is )","title":"within_surrogate()"},{"location":"modules/utils/","text":"Utilities \u00b6 \u00b6 Utilities for working with the Telegram API itself (such as handy methods to convert between an entity like a User, Chat, etc. into its Input version) chunks ( iterable , size = 100 ) \u00b6 Turns the given iterable into chunks of the specified size, which is 100 by default since that's what Telegram uses the most. Source code in telethon\\utils.py 79 80 81 82 83 84 85 86 87 def chunks ( iterable , size = 100 ): \"\"\" Turns the given iterable into chunks of the specified size, which is 100 by default since that's what Telegram uses the most. \"\"\" it = iter ( iterable ) size -= 1 for head in it : yield itertools . chain ([ head ], itertools . islice ( it , size )) decode_waveform ( waveform ) \u00b6 Inverse operation of encode_waveform . Source code in telethon\\utils.py 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def decode_waveform ( waveform ): \"\"\" Inverse operation of `encode_waveform`. \"\"\" bit_count = len ( waveform ) * 8 value_count = bit_count // 5 if value_count == 0 : return b '' result = bytearray ( value_count ) for i in range ( value_count - 1 ): byte_index , bit_shift = divmod ( i * 5 , 8 ) value = struct . unpack ( '<H' , waveform [ byte_index : byte_index + 2 ])[ 0 ] result [ i ] = ( value >> bit_shift ) & 0b00011111 byte_index , bit_shift = divmod ( value_count - 1 , 8 ) if byte_index == len ( waveform ) - 1 : value = waveform [ byte_index ] else : value = struct . unpack ( '<H' , waveform [ byte_index : byte_index + 2 ])[ 0 ] result [ value_count - 1 ] = ( value >> bit_shift ) & 0b00011111 return bytes ( result ) encode_waveform ( waveform ) \u00b6 Encodes the input bytes into a 5-bit byte-string to be used as a voice note's waveform. See decode_waveform for the reverse operation. Example .. code-block:: python chat = ... file = 'my.ogg' # Send 'my.ogg' with a ascending - triangle waveform await client . send_file ( chat , file , attributes = [ types . DocumentAttributeAudio ( duration = 7 , voice = True , waveform = utils . encode_waveform ( bytes ( range ( 2 ** 5 )) # 2 ** 5 because 5 - bit )] # Send 'my.ogg' with a square waveform await client . send_file ( chat , file , attributes = [ types . DocumentAttributeAudio ( duration = 7 , voice = True , waveform = utils . encode_waveform ( bytes (( 31 , 31 , 15 , 15 , 15 , 15 , 31 , 31 )) * 4 ) )] Source code in telethon\\utils.py 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 def encode_waveform ( waveform ): \"\"\" Encodes the input `bytes` into a 5-bit byte-string to be used as a voice note's waveform. See `decode_waveform` for the reverse operation. Example .. code-block:: python chat = ... file = 'my.ogg' # Send 'my.ogg' with a ascending-triangle waveform await client.send_file(chat, file, attributes=[types.DocumentAttributeAudio( duration=7, voice=True, waveform=utils.encode_waveform(bytes(range(2 ** 5)) # 2**5 because 5-bit )] # Send 'my.ogg' with a square waveform await client.send_file(chat, file, attributes=[types.DocumentAttributeAudio( duration=7, voice=True, waveform=utils.encode_waveform(bytes((31, 31, 15, 15, 15, 15, 31, 31)) * 4) )] \"\"\" bits_count = len ( waveform ) * 5 bytes_count = ( bits_count + 7 ) // 8 result = bytearray ( bytes_count + 1 ) for i in range ( len ( waveform )): byte_index , bit_shift = divmod ( i * 5 , 8 ) value = ( waveform [ i ] & 0b00011111 ) << bit_shift or_what = struct . unpack ( '<H' , ( result [ byte_index : byte_index + 2 ]))[ 0 ] or_what |= value result [ byte_index : byte_index + 2 ] = struct . pack ( '<H' , or_what ) return bytes ( result [: bytes_count ]) get_appropriated_part_size ( file_size ) \u00b6 Gets the appropriated part size when uploading or downloading files, given an initial file size. Source code in telethon\\utils.py 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 def get_appropriated_part_size ( file_size ): \"\"\" Gets the appropriated part size when uploading or downloading files, given an initial file size. \"\"\" if file_size <= 104857600 : # 100MB return 128 if file_size <= 786432000 : # 750MB return 256 if file_size <= 1572864000 : # 1500MB return 512 raise ValueError ( 'File size too large' ) get_attributes ( file , * , attributes = None , mime_type = None , force_document = False , voice_note = False , video_note = False , supports_streaming = False ) \u00b6 Get a list of attributes for the given file and the mime type as a tuple ([attribute], mime_type). Source code in telethon\\utils.py 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 def get_attributes ( file , * , attributes = None , mime_type = None , force_document = False , voice_note = False , video_note = False , supports_streaming = False ): \"\"\" Get a list of attributes for the given file and the mime type as a tuple ([attribute], mime_type). \"\"\" # Note: ``file.name`` works for :tl:`InputFile` and some `IOBase` streams name = file if isinstance ( file , str ) else getattr ( file , 'name' , 'unnamed' ) if mime_type is None : mime_type = mimetypes . guess_type ( name )[ 0 ] attr_dict = { types . DocumentAttributeFilename : types . DocumentAttributeFilename ( os . path . basename ( name ))} if is_audio ( file ): m = _get_metadata ( file ) if m : attr_dict [ types . DocumentAttributeAudio ] = \\ types . DocumentAttributeAudio ( voice = voice_note , title = m . get ( 'title' ) if m . has ( 'title' ) else None , performer = m . get ( 'author' ) if m . has ( 'author' ) else None , duration = int ( m . get ( 'duration' ) . seconds if m . has ( 'duration' ) else 0 ) ) if not force_document and is_video ( file ): m = _get_metadata ( file ) if m : doc = types . DocumentAttributeVideo ( round_message = video_note , w = m . get ( 'width' ) if m . has ( 'width' ) else 0 , h = m . get ( 'height' ) if m . has ( 'height' ) else 0 , duration = int ( m . get ( 'duration' ) . seconds if m . has ( 'duration' ) else 0 ), supports_streaming = supports_streaming ) else : doc = types . DocumentAttributeVideo ( 0 , 1 , 1 , round_message = video_note , supports_streaming = supports_streaming ) attr_dict [ types . DocumentAttributeVideo ] = doc if voice_note : if types . DocumentAttributeAudio in attr_dict : attr_dict [ types . DocumentAttributeAudio ] . voice = True else : attr_dict [ types . DocumentAttributeAudio ] = \\ types . DocumentAttributeAudio ( 0 , voice = True ) # Now override the attributes if any. As we have a dict of # {cls: instance}, we can override any class with the list # of attributes provided by the user easily. if attributes : for a in attributes : attr_dict [ type ( a )] = a # Ensure we have a mime type, any; but it cannot be None # 'The \"octet-stream\" subtype is used to indicate that a body # contains arbitrary binary data.' if not mime_type : mime_type = 'application/octet-stream' return list ( attr_dict . values ()), mime_type get_display_name ( entity ) \u00b6 Gets the display name for the given :tl: User , :tl: Chat or :tl: Channel . Returns an empty string otherwise. Source code in telethon\\utils.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def get_display_name ( entity ): \"\"\" Gets the display name for the given :tl:`User`, :tl:`Chat` or :tl:`Channel`. Returns an empty string otherwise. \"\"\" if isinstance ( entity , types . User ): if entity . last_name and entity . first_name : return ' {} {} ' . format ( entity . first_name , entity . last_name ) elif entity . first_name : return entity . first_name elif entity . last_name : return entity . last_name else : return '' elif isinstance ( entity , ( types . Chat , types . Channel )): return entity . title return '' get_extension ( media ) \u00b6 Gets the corresponding extension for any Telegram media. Source code in telethon\\utils.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def get_extension ( media ): \"\"\"Gets the corresponding extension for any Telegram media.\"\"\" # Photos are always compressed as .jpg by Telegram try : get_input_photo ( media ) return '.jpg' except TypeError : # These cases are not handled by input photo because it can't if isinstance ( media , ( types . UserProfilePhoto , types . ChatPhoto )): return '.jpg' # Documents will come with a mime type if isinstance ( media , types . MessageMediaDocument ): media = media . document if isinstance ( media , ( types . Document , types . WebDocument , types . WebDocumentNoProxy )): if media . mime_type == 'application/octet-stream' : # Octet stream are just bytes, which have no default extension return '' else : return guess_extension ( media . mime_type ) or '' return '' get_inner_text ( text , entities ) \u00b6 Gets the inner text that's surrounded by the given entities. For instance: text = 'hey!', entity = MessageEntityBold(2, 2) -> 'y!'. Parameters: Name Type Description Default text str the original text. required entities Iterable the entity or entities that must be matched. required Returns: Type Description Union[str, list] A single result or a list of the text surrounded by the entities. Source code in telethon\\utils.py 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 def get_inner_text ( text : str , entities : \"Iterable\" ) -> \"Union[str, list]\" : \"\"\" Gets the inner text that's surrounded by the given entities. For instance: text = 'hey!', entity = MessageEntityBold(2, 2) -> 'y!'. Args: text: the original text. entities: the entity or entities that must be matched. Returns: A single result or a list of the text surrounded by the entities. \"\"\" text = add_surrogate ( text ) result = [] for e in entities : start = e . offset end = e . offset + e . length result . append ( del_surrogate ( text [ start : end ])) return result get_input_channel ( entity ) \u00b6 Similar to :meth: get_input_peer , but for :tl: InputChannel 's alone. .. important:: This method does not validate for invalid general - purpose access hashes , unlike `get_input_peer` . Consider using instead : `` get_input_channel ( get_input_peer ( channel )) `` . Source code in telethon\\utils.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def get_input_channel ( entity ): \"\"\" Similar to :meth:`get_input_peer`, but for :tl:`InputChannel`'s alone. .. important:: This method does not validate for invalid general-purpose access hashes, unlike `get_input_peer`. Consider using instead: ``get_input_channel(get_input_peer(channel))``. \"\"\" try : if entity . SUBCLASS_OF_ID == 0x40f202fd : # crc32(b'InputChannel') return entity except AttributeError : _raise_cast_fail ( entity , 'InputChannel' ) if isinstance ( entity , ( types . Channel , types . ChannelForbidden )): return types . InputChannel ( entity . id , entity . access_hash or 0 ) if isinstance ( entity , types . InputPeerChannel ): return types . InputChannel ( entity . channel_id , entity . access_hash ) if isinstance ( entity , types . InputPeerChannelFromMessage ): return types . InputChannelFromMessage ( entity . peer , entity . msg_id , entity . channel_id ) _raise_cast_fail ( entity , 'InputChannel' ) get_input_chat_photo ( photo ) \u00b6 Similar to :meth: get_input_peer , but for chat photos Source code in telethon\\utils.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def get_input_chat_photo ( photo ): \"\"\"Similar to :meth:`get_input_peer`, but for chat photos\"\"\" try : if photo . SUBCLASS_OF_ID == 0xd4eb2d74 : # crc32(b'InputChatPhoto') return photo elif photo . SUBCLASS_OF_ID == 0xe7655f1f : # crc32(b'InputFile'): return types . InputChatUploadedPhoto ( photo ) except AttributeError : _raise_cast_fail ( photo , 'InputChatPhoto' ) photo = get_input_photo ( photo ) if isinstance ( photo , types . InputPhoto ): return types . InputChatPhoto ( photo ) elif isinstance ( photo , types . InputPhotoEmpty ): return types . InputChatPhotoEmpty () _raise_cast_fail ( photo , 'InputChatPhoto' ) get_input_dialog ( dialog ) \u00b6 Similar to :meth: get_input_peer , but for dialogs Source code in telethon\\utils.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 def get_input_dialog ( dialog ): \"\"\"Similar to :meth:`get_input_peer`, but for dialogs\"\"\" try : if dialog . SUBCLASS_OF_ID == 0xa21c9795 : # crc32(b'InputDialogPeer') return dialog if dialog . SUBCLASS_OF_ID == 0xc91c90b6 : # crc32(b'InputPeer') return types . InputDialogPeer ( dialog ) except AttributeError : _raise_cast_fail ( dialog , 'InputDialogPeer' ) try : return types . InputDialogPeer ( get_input_peer ( dialog )) except TypeError : pass _raise_cast_fail ( dialog , 'InputDialogPeer' ) get_input_document ( document ) \u00b6 Similar to :meth: get_input_peer , but for documents Source code in telethon\\utils.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def get_input_document ( document ): \"\"\"Similar to :meth:`get_input_peer`, but for documents\"\"\" try : if document . SUBCLASS_OF_ID == 0xf33fdb68 : # crc32(b'InputDocument'): return document except AttributeError : _raise_cast_fail ( document , 'InputDocument' ) if isinstance ( document , types . Document ): return types . InputDocument ( id = document . id , access_hash = document . access_hash , file_reference = document . file_reference ) if isinstance ( document , types . DocumentEmpty ): return types . InputDocumentEmpty () if isinstance ( document , types . MessageMediaDocument ): return get_input_document ( document . document ) if isinstance ( document , types . Message ): return get_input_document ( document . media ) _raise_cast_fail ( document , 'InputDocument' ) get_input_geo ( geo ) \u00b6 Similar to :meth: get_input_peer , but for geo points Source code in telethon\\utils.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 def get_input_geo ( geo ): \"\"\"Similar to :meth:`get_input_peer`, but for geo points\"\"\" try : if geo . SUBCLASS_OF_ID == 0x430d225 : # crc32(b'InputGeoPoint'): return geo except AttributeError : _raise_cast_fail ( geo , 'InputGeoPoint' ) if isinstance ( geo , types . GeoPoint ): return types . InputGeoPoint ( lat = geo . lat , long = geo . long ) if isinstance ( geo , types . GeoPointEmpty ): return types . InputGeoPointEmpty () if isinstance ( geo , types . MessageMediaGeo ): return get_input_geo ( geo . geo ) if isinstance ( geo , types . Message ): return get_input_geo ( geo . media ) _raise_cast_fail ( geo , 'InputGeoPoint' ) get_input_location ( location ) \u00b6 Similar to :meth: get_input_peer , but for input messages. Note that this returns a tuple (dc_id, location) , the dc_id being present if known. Source code in telethon\\utils.py 696 697 698 699 700 701 702 703 704 def get_input_location ( location ): \"\"\" Similar to :meth:`get_input_peer`, but for input messages. Note that this returns a tuple ``(dc_id, location)``, the ``dc_id`` being present if known. \"\"\" info = _get_file_info ( location ) return info . dc_id , info . location get_input_media ( media , * , is_photo = False , attributes = None , force_document = False , voice_note = False , video_note = False , supports_streaming = False ) \u00b6 Similar to :meth: get_input_peer , but for media. If the media is :tl: InputFile and is_photo is known to be True , it will be treated as an :tl: InputMediaUploadedPhoto . Else, the rest of parameters will indicate how to treat it. Source code in telethon\\utils.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 def get_input_media ( media , * , is_photo = False , attributes = None , force_document = False , voice_note = False , video_note = False , supports_streaming = False ): \"\"\" Similar to :meth:`get_input_peer`, but for media. If the media is :tl:`InputFile` and ``is_photo`` is known to be `True`, it will be treated as an :tl:`InputMediaUploadedPhoto`. Else, the rest of parameters will indicate how to treat it. \"\"\" try : if media . SUBCLASS_OF_ID == 0xfaf846f4 : # crc32(b'InputMedia') return media elif media . SUBCLASS_OF_ID == 0x846363e0 : # crc32(b'InputPhoto') return types . InputMediaPhoto ( media ) elif media . SUBCLASS_OF_ID == 0xf33fdb68 : # crc32(b'InputDocument') return types . InputMediaDocument ( media ) except AttributeError : _raise_cast_fail ( media , 'InputMedia' ) if isinstance ( media , types . MessageMediaPhoto ): return types . InputMediaPhoto ( id = get_input_photo ( media . photo ), ttl_seconds = media . ttl_seconds ) if isinstance ( media , ( types . Photo , types . photos . Photo , types . PhotoEmpty )): return types . InputMediaPhoto ( id = get_input_photo ( media ) ) if isinstance ( media , types . MessageMediaDocument ): return types . InputMediaDocument ( id = get_input_document ( media . document ), ttl_seconds = media . ttl_seconds ) if isinstance ( media , ( types . Document , types . DocumentEmpty )): return types . InputMediaDocument ( id = get_input_document ( media ) ) if isinstance ( media , ( types . InputFile , types . InputFileBig )): if is_photo : return types . InputMediaUploadedPhoto ( file = media ) else : attrs , mime = get_attributes ( media , attributes = attributes , force_document = force_document , voice_note = voice_note , video_note = video_note , supports_streaming = supports_streaming ) return types . InputMediaUploadedDocument ( file = media , mime_type = mime , attributes = attrs ) if isinstance ( media , types . MessageMediaGame ): return types . InputMediaGame ( id = types . InputGameID ( id = media . game . id , access_hash = media . game . access_hash )) if isinstance ( media , types . MessageMediaContact ): return types . InputMediaContact ( phone_number = media . phone_number , first_name = media . first_name , last_name = media . last_name , vcard = '' ) if isinstance ( media , types . MessageMediaGeo ): return types . InputMediaGeoPoint ( geo_point = get_input_geo ( media . geo )) if isinstance ( media , types . MessageMediaVenue ): return types . InputMediaVenue ( geo_point = get_input_geo ( media . geo ), title = media . title , address = media . address , provider = media . provider , venue_id = media . venue_id , venue_type = '' ) if isinstance ( media , types . MessageMediaDice ): return types . InputMediaDice ( media . emoticon ) if isinstance ( media , ( types . MessageMediaEmpty , types . MessageMediaUnsupported , types . ChatPhotoEmpty , types . UserProfilePhotoEmpty , types . ChatPhoto , types . UserProfilePhoto , types . FileLocationToBeDeprecated )): return types . InputMediaEmpty () if isinstance ( media , types . Message ): return get_input_media ( media . media , is_photo = is_photo ) _raise_cast_fail ( media , 'InputMedia' ) get_input_message ( message ) \u00b6 Similar to :meth: get_input_peer , but for input messages. Source code in telethon\\utils.py 531 532 533 534 535 536 537 538 539 540 541 542 543 def get_input_message ( message ): \"\"\"Similar to :meth:`get_input_peer`, but for input messages.\"\"\" try : if isinstance ( message , int ): # This case is really common too return types . InputMessageID ( message ) elif message . SUBCLASS_OF_ID == 0x54b6bcc5 : # crc32(b'InputMessage'): return message elif message . SUBCLASS_OF_ID == 0x790009e3 : # crc32(b'Message'): return types . InputMessageID ( message . id ) except AttributeError : pass _raise_cast_fail ( message , 'InputMedia' ) get_input_peer ( entity , allow_self = True , check_hash = True ) \u00b6 Gets the input peer for the given \"entity\" (user, chat or channel). A TypeError is raised if the given entity isn't a supported type or if check_hash is True but the entity's access_hash is None or the entity contains min information. In this case, the hash cannot be used for general purposes, and thus is not returned to avoid any issues which can derive from invalid access hashes. Note that check_hash is ignored if an input peer is already passed since in that case we assume the user knows what they're doing. This is key to getting entities by explicitly passing hash = 0 . Source code in telethon\\utils.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def get_input_peer ( entity , allow_self = True , check_hash = True ): \"\"\" Gets the input peer for the given \"entity\" (user, chat or channel). A ``TypeError`` is raised if the given entity isn't a supported type or if ``check_hash is True`` but the entity's ``access_hash is None`` *or* the entity contains ``min`` information. In this case, the hash cannot be used for general purposes, and thus is not returned to avoid any issues which can derive from invalid access hashes. Note that ``check_hash`` **is ignored** if an input peer is already passed since in that case we assume the user knows what they're doing. This is key to getting entities by explicitly passing ``hash = 0``. \"\"\" # NOTE: It is important that this method validates the access hashes, # because it is used when we *require* a valid general-purpose # access hash. This includes caching, which relies on this method. # Further, when resolving raw methods, they do e.g., # utils.get_input_channel(client.get_input_peer(...)) # # ...which means that the client's method verifies the hashes. # # Excerpt from a conversation with official developers (slightly edited): # > We send new access_hash for Channel with min flag since layer 102. # > Previously, we omitted it. # > That one works just to download the profile picture. # # < So, min hashes only work for getting files, # < but the non-min hash is required for any other operation? # # > Yes. # # More information: https://core.telegram.org/api/min try : if entity . SUBCLASS_OF_ID == 0xc91c90b6 : # crc32(b'InputPeer') return entity except AttributeError : # e.g. custom.Dialog (can't cyclic import). if allow_self and hasattr ( entity , 'input_entity' ): return entity . input_entity elif hasattr ( entity , 'entity' ): return get_input_peer ( entity . entity ) else : _raise_cast_fail ( entity , 'InputPeer' ) if isinstance ( entity , types . User ): if entity . is_self and allow_self : return types . InputPeerSelf () elif ( entity . access_hash is not None and not entity . min ) or not check_hash : return types . InputPeerUser ( entity . id , entity . access_hash ) else : raise TypeError ( 'User without access_hash or min info cannot be input' ) if isinstance ( entity , ( types . Chat , types . ChatEmpty , types . ChatForbidden )): return types . InputPeerChat ( entity . id ) if isinstance ( entity , types . Channel ): if ( entity . access_hash is not None and not entity . min ) or not check_hash : return types . InputPeerChannel ( entity . id , entity . access_hash ) else : raise TypeError ( 'Channel without access_hash or min info cannot be input' ) if isinstance ( entity , types . ChannelForbidden ): # \"channelForbidden are never min\", and since their hash is # also not optional, we assume that this truly is the case. return types . InputPeerChannel ( entity . id , entity . access_hash ) if isinstance ( entity , types . InputUser ): return types . InputPeerUser ( entity . user_id , entity . access_hash ) if isinstance ( entity , types . InputChannel ): return types . InputPeerChannel ( entity . channel_id , entity . access_hash ) if isinstance ( entity , types . InputUserSelf ): return types . InputPeerSelf () if isinstance ( entity , types . InputUserFromMessage ): return types . InputPeerUserFromMessage ( entity . peer , entity . msg_id , entity . user_id ) if isinstance ( entity , types . InputChannelFromMessage ): return types . InputPeerChannelFromMessage ( entity . peer , entity . msg_id , entity . channel_id ) if isinstance ( entity , types . UserEmpty ): return types . InputPeerEmpty () if isinstance ( entity , types . UserFull ): return get_input_peer ( entity . user ) if isinstance ( entity , types . ChatFull ): return types . InputPeerChat ( entity . id ) if isinstance ( entity , types . PeerChat ): return types . InputPeerChat ( entity . chat_id ) _raise_cast_fail ( entity , 'InputPeer' ) get_input_photo ( photo ) \u00b6 Similar to :meth: get_input_peer , but for photos Source code in telethon\\utils.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def get_input_photo ( photo ): \"\"\"Similar to :meth:`get_input_peer`, but for photos\"\"\" try : if photo . SUBCLASS_OF_ID == 0x846363e0 : # crc32(b'InputPhoto'): return photo except AttributeError : _raise_cast_fail ( photo , 'InputPhoto' ) if isinstance ( photo , types . Message ): photo = photo . media if isinstance ( photo , ( types . photos . Photo , types . MessageMediaPhoto )): photo = photo . photo if isinstance ( photo , types . Photo ): return types . InputPhoto ( id = photo . id , access_hash = photo . access_hash , file_reference = photo . file_reference ) if isinstance ( photo , types . PhotoEmpty ): return types . InputPhotoEmpty () if isinstance ( photo , types . messages . ChatFull ): photo = photo . full_chat if isinstance ( photo , types . ChannelFull ): return get_input_photo ( photo . chat_photo ) elif isinstance ( photo , types . UserFull ): return get_input_photo ( photo . profile_photo ) elif isinstance ( photo , ( types . Channel , types . Chat , types . User )): return get_input_photo ( photo . photo ) if isinstance ( photo , ( types . UserEmpty , types . ChatEmpty , types . ChatForbidden , types . ChannelForbidden )): return types . InputPhotoEmpty () _raise_cast_fail ( photo , 'InputPhoto' ) get_input_user ( entity ) \u00b6 Similar to :meth: get_input_peer , but for :tl: InputUser 's alone. .. important:: This method does not validate for invalid general - purpose access hashes , unlike `get_input_peer` . Consider using instead : `` get_input_channel ( get_input_peer ( channel )) `` . Source code in telethon\\utils.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def get_input_user ( entity ): \"\"\" Similar to :meth:`get_input_peer`, but for :tl:`InputUser`'s alone. .. important:: This method does not validate for invalid general-purpose access hashes, unlike `get_input_peer`. Consider using instead: ``get_input_channel(get_input_peer(channel))``. \"\"\" try : if entity . SUBCLASS_OF_ID == 0xe669bf46 : # crc32(b'InputUser'): return entity except AttributeError : _raise_cast_fail ( entity , 'InputUser' ) if isinstance ( entity , types . User ): if entity . is_self : return types . InputUserSelf () else : return types . InputUser ( entity . id , entity . access_hash or 0 ) if isinstance ( entity , types . InputPeerSelf ): return types . InputUserSelf () if isinstance ( entity , ( types . UserEmpty , types . InputPeerEmpty )): return types . InputUserEmpty () if isinstance ( entity , types . UserFull ): return get_input_user ( entity . user ) if isinstance ( entity , types . InputPeerUser ): return types . InputUser ( entity . user_id , entity . access_hash ) if isinstance ( entity , types . InputPeerUserFromMessage ): return types . InputUserFromMessage ( entity . peer , entity . msg_id , entity . user_id ) _raise_cast_fail ( entity , 'InputUser' ) get_message_id ( message ) \u00b6 Similar to :meth: get_input_peer , but for message IDs. Source code in telethon\\utils.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def get_message_id ( message ): \"\"\"Similar to :meth:`get_input_peer`, but for message IDs.\"\"\" if message is None : return None if isinstance ( message , int ): return message try : if message . SUBCLASS_OF_ID == 0x790009e3 : # hex(crc32(b'Message')) = 0x790009e3 return message . id except AttributeError : pass raise TypeError ( 'Invalid message type: {} ' . format ( type ( message ))) get_peer_id ( peer , add_mark = True ) \u00b6 Convert the given peer into its marked ID by default. This \"mark\" comes from the \"bot api\" format, and with it the peer type can be identified back. User ID is left unmodified, chat ID is negated, and channel ID is prefixed with -100: user_id -chat_id -100channel_id The original ID and the peer type class can be returned with a call to :meth: resolve_id(marked_id) . Source code in telethon\\utils.py 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 def get_peer_id ( peer , add_mark = True ): \"\"\" Convert the given peer into its marked ID by default. This \"mark\" comes from the \"bot api\" format, and with it the peer type can be identified back. User ID is left unmodified, chat ID is negated, and channel ID is prefixed with -100: * ``user_id`` * ``-chat_id`` * ``-100channel_id`` The original ID and the peer type class can be returned with a call to :meth:`resolve_id(marked_id)`. \"\"\" # First we assert it's a Peer TLObject, or early return for integers if isinstance ( peer , int ): return peer if add_mark else resolve_id ( peer )[ 0 ] # Tell the user to use their client to resolve InputPeerSelf if we got one if isinstance ( peer , types . InputPeerSelf ): _raise_cast_fail ( peer , 'int (you might want to use client.get_peer_id)' ) try : peer = get_peer ( peer ) except TypeError : _raise_cast_fail ( peer , 'int' ) if isinstance ( peer , types . PeerUser ): return peer . user_id elif isinstance ( peer , types . PeerChat ): # Check in case the user mixed things up to avoid blowing up if not ( 0 < peer . chat_id <= 0x7fffffff ): peer . chat_id = resolve_id ( peer . chat_id )[ 0 ] return - peer . chat_id if add_mark else peer . chat_id else : # if isinstance(peer, types.PeerChannel): # Check in case the user mixed things up to avoid blowing up if not ( 0 < peer . channel_id <= 0x7fffffff ): peer . channel_id = resolve_id ( peer . channel_id )[ 0 ] if not add_mark : return peer . channel_id # Concat -100 through math tricks, .to_supergroup() on # Madeline IDs will be strictly positive -> log works. try : return - ( peer . channel_id + pow ( 10 , math . floor ( math . log10 ( peer . channel_id ) + 3 ))) except ValueError : raise TypeError ( 'Cannot get marked ID of a channel ' 'unless its ID is strictly positive' ) from None is_audio ( file ) \u00b6 Returns True if the file extension looks like an audio file. Source code in telethon\\utils.py 784 785 786 787 def is_audio ( file ): \"\"\"Returns `True` if the file extension looks like an audio file.\"\"\" file = 'a' + _get_extension ( file ) return ( mimetypes . guess_type ( file )[ 0 ] or '' ) . startswith ( 'audio/' ) is_gif ( file ) \u00b6 Returns True if the file extension looks like a gif file to Telegram. Source code in telethon\\utils.py 777 778 779 780 781 def is_gif ( file ): \"\"\" Returns `True` if the file extension looks like a gif file to Telegram. \"\"\" return re . match ( r '\\.gif' , _get_extension ( file ), re . IGNORECASE ) is_image ( file ) \u00b6 Returns True if the file extension looks like an image file to Telegram. Source code in telethon\\utils.py 766 767 768 769 770 771 772 773 774 def is_image ( file ): \"\"\" Returns `True` if the file extension looks like an image file to Telegram. \"\"\" match = re . match ( r '\\.(png|jpe?g)' , _get_extension ( file ), re . IGNORECASE ) if match : return True else : return isinstance ( resolve_bot_file_id ( file ), types . Photo ) is_list_like ( obj ) \u00b6 Returns True if the given object looks like a list. Checking if hasattr(obj, '__iter__') and ignoring str/bytes is not enough. Things like open() are also iterable (and probably many other things), so just support the commonly known list-like objects. Source code in telethon\\utils.py 796 797 798 799 800 801 802 803 804 def is_list_like ( obj ): \"\"\" Returns `True` if the given object looks like a list. Checking ``if hasattr(obj, '__iter__')`` and ignoring ``str/bytes`` is not enough. Things like ``open()`` are also iterable (and probably many other things), so just support the commonly known list-like objects. \"\"\" return isinstance ( obj , ( list , tuple , set , dict , GeneratorType )) is_video ( file ) \u00b6 Returns True if the file extension looks like a video file. Source code in telethon\\utils.py 790 791 792 793 def is_video ( file ): \"\"\"Returns `True` if the file extension looks like a video file.\"\"\" file = 'a' + _get_extension ( file ) return ( mimetypes . guess_type ( file )[ 0 ] or '' ) . startswith ( 'video/' ) pack_bot_file_id ( file ) \u00b6 Inverse operation for resolve_bot_file_id . The only parameters this method will accept are :tl: Document and :tl: Photo , and it will return a variable-length file_id string. If an invalid parameter is given, it will return None . Source code in telethon\\utils.py 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 def pack_bot_file_id ( file ): \"\"\" Inverse operation for `resolve_bot_file_id`. The only parameters this method will accept are :tl:`Document` and :tl:`Photo`, and it will return a variable-length ``file_id`` string. If an invalid parameter is given, it will ``return None``. \"\"\" if isinstance ( file , types . MessageMediaDocument ): file = file . document elif isinstance ( file , types . MessageMediaPhoto ): file = file . photo if isinstance ( file , types . Document ): file_type = 5 for attribute in file . attributes : if isinstance ( attribute , types . DocumentAttributeAudio ): file_type = 3 if attribute . voice else 9 elif isinstance ( attribute , types . DocumentAttributeVideo ): file_type = 13 if attribute . round_message else 4 elif isinstance ( attribute , types . DocumentAttributeSticker ): file_type = 8 elif isinstance ( attribute , types . DocumentAttributeAnimated ): file_type = 10 else : continue break return _encode_telegram_base64 ( _rle_encode ( struct . pack ( '<iiqqb' , file_type , file . dc_id , file . id , file . access_hash , 2 ))) elif isinstance ( file , types . Photo ): size = next (( x for x in reversed ( file . sizes ) if isinstance ( x , ( types . PhotoSize , types . PhotoCachedSize ))), None ) if not size : return None size = size . location return _encode_telegram_base64 ( _rle_encode ( struct . pack ( '<iiqqqqib' , 2 , file . dc_id , file . id , file . access_hash , size . volume_id , 0 , size . local_id , 2 # 0 = old `secret` ))) else : return None parse_phone ( phone ) \u00b6 Parses the given phone, or returns None if it's invalid. Source code in telethon\\utils.py 807 808 809 810 811 812 813 814 def parse_phone ( phone ): \"\"\"Parses the given phone, or returns `None` if it's invalid.\"\"\" if isinstance ( phone , int ): return str ( phone ) else : phone = re . sub ( r '[+()\\s-]' , '' , str ( phone )) if phone . isdigit (): return phone parse_username ( username ) \u00b6 Parses the given username or channel access hash, given a string, username or URL. Returns a tuple consisting of both the stripped, lowercase username and whether it is a joinchat/ hash (in which case is not lowercase'd). Returns (None, False) if the username or link is not valid. Source code in telethon\\utils.py 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 def parse_username ( username ): \"\"\" Parses the given username or channel access hash, given a string, username or URL. Returns a tuple consisting of both the stripped, lowercase username and whether it is a joinchat/ hash (in which case is not lowercase'd). Returns ``(None, False)`` if the ``username`` or link is not valid. \"\"\" username = username . strip () m = USERNAME_RE . match ( username ) or TG_JOIN_RE . match ( username ) if m : username = username [ m . end ():] is_invite = bool ( m . group ( 1 )) if is_invite : return username , True else : username = username . rstrip ( '/' ) if VALID_USERNAME_RE . match ( username ): return username . lower (), False else : return None , False resolve_bot_file_id ( file_id ) \u00b6 Given a Bot API-style file_id <telethon.tl.custom.file.File.id> , returns the media it represents. If the file_id <telethon.tl.custom.file.File.id> is not valid, None is returned instead. Note that the file_id <telethon.tl.custom.file.File.id> does not have information such as image dimensions or file size, so these will be zero if present. For thumbnails, the photo ID and hash will always be zero. Source code in telethon\\utils.py 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 def resolve_bot_file_id ( file_id ): \"\"\" Given a Bot API-style `file_id <telethon.tl.custom.file.File.id>`, returns the media it represents. If the `file_id <telethon.tl.custom.file.File.id>` is not valid, `None` is returned instead. Note that the `file_id <telethon.tl.custom.file.File.id>` does not have information such as image dimensions or file size, so these will be zero if present. For thumbnails, the photo ID and hash will always be zero. \"\"\" data = _rle_decode ( _decode_telegram_base64 ( file_id )) if not data : return None # This isn't officially documented anywhere, but # we assume the last byte is some kind of \"version\". data , version = data [: - 1 ], data [ - 1 ] if version not in ( 2 , 4 ): return None if ( version == 2 and len ( data ) == 24 ) or ( version == 4 and len ( data ) == 25 ): if version == 2 : file_type , dc_id , media_id , access_hash = struct . unpack ( '<iiqq' , data ) # elif version == 4: else : # TODO Figure out what the extra byte means file_type , dc_id , media_id , access_hash , _ = struct . unpack ( '<iiqqb' , data ) if not ( 1 <= dc_id <= 5 ): # Valid `file_id`'s must have valid DC IDs. Since this method is # called when sending a file and the user may have entered a path # they believe is correct but the file doesn't exist, this method # may detect a path as \"valid\" bot `file_id` even when it's not. # By checking the `dc_id`, we greatly reduce the chances of this # happening. return None attributes = [] if file_type == 3 or file_type == 9 : attributes . append ( types . DocumentAttributeAudio ( duration = 0 , voice = file_type == 3 )) elif file_type == 4 or file_type == 13 : attributes . append ( types . DocumentAttributeVideo ( duration = 0 , w = 0 , h = 0 , round_message = file_type == 13 )) # elif file_type == 5: # other, cannot know which elif file_type == 8 : attributes . append ( types . DocumentAttributeSticker ( alt = '' , stickerset = types . InputStickerSetEmpty () )) elif file_type == 10 : attributes . append ( types . DocumentAttributeAnimated ()) return types . Document ( id = media_id , access_hash = access_hash , date = None , mime_type = '' , size = 0 , thumbs = None , dc_id = dc_id , attributes = attributes , file_reference = b '' ) elif ( version == 2 and len ( data ) == 44 ) or ( version == 4 and len ( data ) == 49 ): if version == 2 : ( file_type , dc_id , media_id , access_hash , volume_id , secret , local_id ) = struct . unpack ( '<iiqqqqi' , data ) # elif version == 4: else : # TODO Figure out what the extra five bytes mean ( file_type , dc_id , media_id , access_hash , volume_id , secret , local_id , _ ) = struct . unpack ( '<iiqqqqi5s' , data ) if not ( 1 <= dc_id <= 5 ): return None # Thumbnails (small) always have ID 0; otherwise size 'x' photo_size = 's' if media_id or access_hash else 'x' return types . Photo ( id = media_id , access_hash = access_hash , file_reference = b '' , date = None , sizes = [ types . PhotoSize ( type = photo_size , location = types . FileLocationToBeDeprecated ( volume_id = volume_id , local_id = local_id ), w = 0 , h = 0 , size = 0 )], dc_id = dc_id , has_stickers = None ) resolve_id ( marked_id ) \u00b6 Given a marked ID, returns the original ID and its :tl: Peer type. Source code in telethon\\utils.py 948 949 950 951 952 953 954 955 956 957 958 959 960 961 def resolve_id ( marked_id ): \"\"\"Given a marked ID, returns the original ID and its :tl:`Peer` type.\"\"\" if marked_id >= 0 : return marked_id , types . PeerUser # There have been report of chat IDs being 10000xyz, which means their # marked version is -10000xyz, which in turn looks like a channel but # it becomes 00xyz (= xyz). Hence, we must assert that there are only # two zeroes. m = re . match ( r '-100([^0]\\d*)' , str ( marked_id )) if m : return int ( m . group ( 1 )), types . PeerChannel return - marked_id , types . PeerChat resolve_inline_message_id ( inline_msg_id ) \u00b6 Resolves an inline message ID. Returns a tuple of (message id, peer, dc id, access hash) The peer may either be a :tl: PeerUser referencing the user who sent the message via the bot in a private conversation or small group chat, or a :tl: PeerChannel if the message was sent in a channel. The access_hash does not have any use yet. Source code in telethon\\utils.py 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 def resolve_inline_message_id ( inline_msg_id ): \"\"\" Resolves an inline message ID. Returns a tuple of ``(message id, peer, dc id, access hash)`` The ``peer`` may either be a :tl:`PeerUser` referencing the user who sent the message via the bot in a private conversation or small group chat, or a :tl:`PeerChannel` if the message was sent in a channel. The ``access_hash`` does not have any use yet. \"\"\" try : dc_id , message_id , pid , access_hash = \\ struct . unpack ( '<iiiq' , _decode_telegram_base64 ( inline_msg_id )) peer = types . PeerChannel ( - pid ) if pid < 0 else types . PeerUser ( pid ) return message_id , peer , dc_id , access_hash except ( struct . error , TypeError ): return None , None , None , None resolve_invite_link ( link ) \u00b6 Resolves the given invite link. Returns a tuple of (link creator user id, global chat id, random int) . Note that for broadcast channels, the link creator user ID will be zero to protect their identity. Normal chats and megagroup channels will have such ID. Note that the chat ID may not be accurate for chats with a link that were upgraded to megagroup, since the link can remain the same, but the chat ID will be correct once a new link is generated. Source code in telethon\\utils.py 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 def resolve_invite_link ( link ): \"\"\" Resolves the given invite link. Returns a tuple of ``(link creator user id, global chat id, random int)``. Note that for broadcast channels, the link creator user ID will be zero to protect their identity. Normal chats and megagroup channels will have such ID. Note that the chat ID may not be accurate for chats with a link that were upgraded to megagroup, since the link can remain the same, but the chat ID will be correct once a new link is generated. \"\"\" link_hash , is_link = parse_username ( link ) if not is_link : # Perhaps the user passed the link hash directly link_hash = link # Little known fact, but invite links with a # hex-string of bytes instead of base64 also works. if re . match ( r '[a-fA-F\\d] {32} ' , link_hash ): payload = bytes . fromhex ( link_hash ) else : payload = _decode_telegram_base64 ( link_hash ) try : return struct . unpack ( '>LLQ' , payload ) except ( struct . error , TypeError ): return None , None , None sanitize_parse_mode ( mode ) \u00b6 Converts the given parse mode into an object with parse and unparse callable properties. Source code in telethon\\utils.py 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 def sanitize_parse_mode ( mode ): \"\"\" Converts the given parse mode into an object with ``parse`` and ``unparse`` callable properties. \"\"\" if not mode : return None if callable ( mode ): class CustomMode : @staticmethod def unparse ( text , entities ): raise NotImplementedError CustomMode . parse = mode return CustomMode elif ( all ( hasattr ( mode , x ) for x in ( 'parse' , 'unparse' )) and all ( callable ( x ) for x in ( mode . parse , mode . unparse ))): return mode elif isinstance ( mode , str ): try : return { 'md' : markdown , 'markdown' : markdown , 'htm' : html , 'html' : html }[ mode . lower ()] except KeyError : raise ValueError ( 'Unknown parse mode {} ' . format ( mode )) else : raise TypeError ( 'Invalid parse mode type {} ' . format ( mode )) stripped_photo_to_jpg ( stripped ) \u00b6 Adds the JPG header and footer to a stripped image. Ported from https://github.com/telegramdesktop/tdesktop/blob/bec39d89e19670eb436dc794a8f20b657cb87c71/Telegram/SourceFiles/ui/image/image.cpp#L225 Source code in telethon\\utils.py 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 def stripped_photo_to_jpg ( stripped ): \"\"\" Adds the JPG header and footer to a stripped image. Ported from https://github.com/telegramdesktop/tdesktop/blob/bec39d89e19670eb436dc794a8f20b657cb87c71/Telegram/SourceFiles/ui/image/image.cpp#L225 \"\"\" # NOTE: Changes here should update _photo_size_byte_count if len ( stripped ) < 3 or stripped [ 0 ] != 1 : return stripped header = bytearray ( b ' \\xff\\xd8\\xff\\xe0\\x00\\x10 JFIF \\x00\\x01\\x01\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\xff\\xdb\\x00 C \\x00 ( \\x1c\\x1e # \\x1e\\x19 (#!#-+(0<dA<77<{X]Id \\x91\\x80\\x99\\x96\\x8f\\x80\\x8c\\x8a\\xa0\\xb4\\xe6\\xc3\\xa0\\xaa\\xda\\xad\\x8a\\x8c\\xc8\\xff\\xcb\\xda\\xee\\xf5\\xff\\xff\\xff\\x9b\\xc1\\xff\\xff\\xff\\xfa\\xff\\xe6\\xfd\\xff\\xf8\\xff\\xdb\\x00 C \\x01 +--<5<vAAv \\xf8\\xa5\\x8c\\xa5\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xff\\xc0\\x00\\x11\\x08\\x00\\x00\\x00\\x00\\x03\\x01 \" \\x00\\x02\\x11\\x01\\x03\\x11\\x01\\xff\\xc4\\x00\\x1f\\x00\\x00\\x01\\x05\\x01\\x01\\x01\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\xff\\xc4\\x00\\xb5\\x10\\x00\\x02\\x01\\x03\\x03\\x02\\x04\\x03\\x05\\x05\\x04\\x04\\x00\\x00\\x01 } \\x01\\x02\\x03\\x00\\x04\\x11\\x05\\x12 !1A \\x06\\x13 Qa \\x07 \"q \\x14 2 \\x81\\x91\\xa1\\x08 #B \\xb1\\xc1\\x15 R \\xd1\\xf0 $3br \\x82\\t\\n\\x16\\x17\\x18\\x19\\x1a %& \\' ()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz \\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xff\\xc4\\x00\\x1f\\x01\\x00\\x03\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\xff\\xc4\\x00\\xb5\\x11\\x00\\x02\\x01\\x02\\x04\\x04\\x03\\x04\\x07\\x05\\x04\\x04\\x00\\x01\\x02 w \\x00\\x01\\x02\\x03\\x11\\x04\\x05 !1 \\x06\\x12 AQ \\x07 aq \\x13 \"2 \\x81\\x08\\x14 B \\x91\\xa1\\xb1\\xc1\\t #3R \\xf0\\x15 br \\xd1\\n\\x16 $4 \\xe1 % \\xf1\\x17\\x18\\x19\\x1a & \\' ()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz \\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xff\\xda\\x00\\x0c\\x03\\x01\\x00\\x02\\x11\\x03\\x11\\x00 ? \\x00 ' ) footer = b \" \\xff\\xd9 \" header [ 164 ] = stripped [ 1 ] header [ 166 ] = stripped [ 2 ] return bytes ( header ) + stripped [ 3 :] + footer","title":"Utilities"},{"location":"modules/utils/#utilities","text":"","title":"Utilities"},{"location":"modules/utils/#telethon.utils","text":"Utilities for working with the Telegram API itself (such as handy methods to convert between an entity like a User, Chat, etc. into its Input version)","title":"telethon.utils"},{"location":"modules/utils/#telethon.utils.chunks","text":"Turns the given iterable into chunks of the specified size, which is 100 by default since that's what Telegram uses the most. Source code in telethon\\utils.py 79 80 81 82 83 84 85 86 87 def chunks ( iterable , size = 100 ): \"\"\" Turns the given iterable into chunks of the specified size, which is 100 by default since that's what Telegram uses the most. \"\"\" it = iter ( iterable ) size -= 1 for head in it : yield itertools . chain ([ head ], itertools . islice ( it , size ))","title":"chunks()"},{"location":"modules/utils/#telethon.utils.decode_waveform","text":"Inverse operation of encode_waveform . Source code in telethon\\utils.py 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def decode_waveform ( waveform ): \"\"\" Inverse operation of `encode_waveform`. \"\"\" bit_count = len ( waveform ) * 8 value_count = bit_count // 5 if value_count == 0 : return b '' result = bytearray ( value_count ) for i in range ( value_count - 1 ): byte_index , bit_shift = divmod ( i * 5 , 8 ) value = struct . unpack ( '<H' , waveform [ byte_index : byte_index + 2 ])[ 0 ] result [ i ] = ( value >> bit_shift ) & 0b00011111 byte_index , bit_shift = divmod ( value_count - 1 , 8 ) if byte_index == len ( waveform ) - 1 : value = waveform [ byte_index ] else : value = struct . unpack ( '<H' , waveform [ byte_index : byte_index + 2 ])[ 0 ] result [ value_count - 1 ] = ( value >> bit_shift ) & 0b00011111 return bytes ( result )","title":"decode_waveform()"},{"location":"modules/utils/#telethon.utils.encode_waveform","text":"Encodes the input bytes into a 5-bit byte-string to be used as a voice note's waveform. See decode_waveform for the reverse operation. Example .. code-block:: python chat = ... file = 'my.ogg' # Send 'my.ogg' with a ascending - triangle waveform await client . send_file ( chat , file , attributes = [ types . DocumentAttributeAudio ( duration = 7 , voice = True , waveform = utils . encode_waveform ( bytes ( range ( 2 ** 5 )) # 2 ** 5 because 5 - bit )] # Send 'my.ogg' with a square waveform await client . send_file ( chat , file , attributes = [ types . DocumentAttributeAudio ( duration = 7 , voice = True , waveform = utils . encode_waveform ( bytes (( 31 , 31 , 15 , 15 , 15 , 15 , 31 , 31 )) * 4 ) )] Source code in telethon\\utils.py 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 def encode_waveform ( waveform ): \"\"\" Encodes the input `bytes` into a 5-bit byte-string to be used as a voice note's waveform. See `decode_waveform` for the reverse operation. Example .. code-block:: python chat = ... file = 'my.ogg' # Send 'my.ogg' with a ascending-triangle waveform await client.send_file(chat, file, attributes=[types.DocumentAttributeAudio( duration=7, voice=True, waveform=utils.encode_waveform(bytes(range(2 ** 5)) # 2**5 because 5-bit )] # Send 'my.ogg' with a square waveform await client.send_file(chat, file, attributes=[types.DocumentAttributeAudio( duration=7, voice=True, waveform=utils.encode_waveform(bytes((31, 31, 15, 15, 15, 15, 31, 31)) * 4) )] \"\"\" bits_count = len ( waveform ) * 5 bytes_count = ( bits_count + 7 ) // 8 result = bytearray ( bytes_count + 1 ) for i in range ( len ( waveform )): byte_index , bit_shift = divmod ( i * 5 , 8 ) value = ( waveform [ i ] & 0b00011111 ) << bit_shift or_what = struct . unpack ( '<H' , ( result [ byte_index : byte_index + 2 ]))[ 0 ] or_what |= value result [ byte_index : byte_index + 2 ] = struct . pack ( '<H' , or_what ) return bytes ( result [: bytes_count ])","title":"encode_waveform()"},{"location":"modules/utils/#telethon.utils.get_appropriated_part_size","text":"Gets the appropriated part size when uploading or downloading files, given an initial file size. Source code in telethon\\utils.py 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 def get_appropriated_part_size ( file_size ): \"\"\" Gets the appropriated part size when uploading or downloading files, given an initial file size. \"\"\" if file_size <= 104857600 : # 100MB return 128 if file_size <= 786432000 : # 750MB return 256 if file_size <= 1572864000 : # 1500MB return 512 raise ValueError ( 'File size too large' )","title":"get_appropriated_part_size()"},{"location":"modules/utils/#telethon.utils.get_attributes","text":"Get a list of attributes for the given file and the mime type as a tuple ([attribute], mime_type). Source code in telethon\\utils.py 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 def get_attributes ( file , * , attributes = None , mime_type = None , force_document = False , voice_note = False , video_note = False , supports_streaming = False ): \"\"\" Get a list of attributes for the given file and the mime type as a tuple ([attribute], mime_type). \"\"\" # Note: ``file.name`` works for :tl:`InputFile` and some `IOBase` streams name = file if isinstance ( file , str ) else getattr ( file , 'name' , 'unnamed' ) if mime_type is None : mime_type = mimetypes . guess_type ( name )[ 0 ] attr_dict = { types . DocumentAttributeFilename : types . DocumentAttributeFilename ( os . path . basename ( name ))} if is_audio ( file ): m = _get_metadata ( file ) if m : attr_dict [ types . DocumentAttributeAudio ] = \\ types . DocumentAttributeAudio ( voice = voice_note , title = m . get ( 'title' ) if m . has ( 'title' ) else None , performer = m . get ( 'author' ) if m . has ( 'author' ) else None , duration = int ( m . get ( 'duration' ) . seconds if m . has ( 'duration' ) else 0 ) ) if not force_document and is_video ( file ): m = _get_metadata ( file ) if m : doc = types . DocumentAttributeVideo ( round_message = video_note , w = m . get ( 'width' ) if m . has ( 'width' ) else 0 , h = m . get ( 'height' ) if m . has ( 'height' ) else 0 , duration = int ( m . get ( 'duration' ) . seconds if m . has ( 'duration' ) else 0 ), supports_streaming = supports_streaming ) else : doc = types . DocumentAttributeVideo ( 0 , 1 , 1 , round_message = video_note , supports_streaming = supports_streaming ) attr_dict [ types . DocumentAttributeVideo ] = doc if voice_note : if types . DocumentAttributeAudio in attr_dict : attr_dict [ types . DocumentAttributeAudio ] . voice = True else : attr_dict [ types . DocumentAttributeAudio ] = \\ types . DocumentAttributeAudio ( 0 , voice = True ) # Now override the attributes if any. As we have a dict of # {cls: instance}, we can override any class with the list # of attributes provided by the user easily. if attributes : for a in attributes : attr_dict [ type ( a )] = a # Ensure we have a mime type, any; but it cannot be None # 'The \"octet-stream\" subtype is used to indicate that a body # contains arbitrary binary data.' if not mime_type : mime_type = 'application/octet-stream' return list ( attr_dict . values ()), mime_type","title":"get_attributes()"},{"location":"modules/utils/#telethon.utils.get_display_name","text":"Gets the display name for the given :tl: User , :tl: Chat or :tl: Channel . Returns an empty string otherwise. Source code in telethon\\utils.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def get_display_name ( entity ): \"\"\" Gets the display name for the given :tl:`User`, :tl:`Chat` or :tl:`Channel`. Returns an empty string otherwise. \"\"\" if isinstance ( entity , types . User ): if entity . last_name and entity . first_name : return ' {} {} ' . format ( entity . first_name , entity . last_name ) elif entity . first_name : return entity . first_name elif entity . last_name : return entity . last_name else : return '' elif isinstance ( entity , ( types . Chat , types . Channel )): return entity . title return ''","title":"get_display_name()"},{"location":"modules/utils/#telethon.utils.get_extension","text":"Gets the corresponding extension for any Telegram media. Source code in telethon\\utils.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def get_extension ( media ): \"\"\"Gets the corresponding extension for any Telegram media.\"\"\" # Photos are always compressed as .jpg by Telegram try : get_input_photo ( media ) return '.jpg' except TypeError : # These cases are not handled by input photo because it can't if isinstance ( media , ( types . UserProfilePhoto , types . ChatPhoto )): return '.jpg' # Documents will come with a mime type if isinstance ( media , types . MessageMediaDocument ): media = media . document if isinstance ( media , ( types . Document , types . WebDocument , types . WebDocumentNoProxy )): if media . mime_type == 'application/octet-stream' : # Octet stream are just bytes, which have no default extension return '' else : return guess_extension ( media . mime_type ) or '' return ''","title":"get_extension()"},{"location":"modules/utils/#telethon.utils.get_inner_text","text":"Gets the inner text that's surrounded by the given entities. For instance: text = 'hey!', entity = MessageEntityBold(2, 2) -> 'y!'. Parameters: Name Type Description Default text str the original text. required entities Iterable the entity or entities that must be matched. required Returns: Type Description Union[str, list] A single result or a list of the text surrounded by the entities. Source code in telethon\\utils.py 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 def get_inner_text ( text : str , entities : \"Iterable\" ) -> \"Union[str, list]\" : \"\"\" Gets the inner text that's surrounded by the given entities. For instance: text = 'hey!', entity = MessageEntityBold(2, 2) -> 'y!'. Args: text: the original text. entities: the entity or entities that must be matched. Returns: A single result or a list of the text surrounded by the entities. \"\"\" text = add_surrogate ( text ) result = [] for e in entities : start = e . offset end = e . offset + e . length result . append ( del_surrogate ( text [ start : end ])) return result","title":"get_inner_text()"},{"location":"modules/utils/#telethon.utils.get_input_channel","text":"Similar to :meth: get_input_peer , but for :tl: InputChannel 's alone. .. important:: This method does not validate for invalid general - purpose access hashes , unlike `get_input_peer` . Consider using instead : `` get_input_channel ( get_input_peer ( channel )) `` . Source code in telethon\\utils.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def get_input_channel ( entity ): \"\"\" Similar to :meth:`get_input_peer`, but for :tl:`InputChannel`'s alone. .. important:: This method does not validate for invalid general-purpose access hashes, unlike `get_input_peer`. Consider using instead: ``get_input_channel(get_input_peer(channel))``. \"\"\" try : if entity . SUBCLASS_OF_ID == 0x40f202fd : # crc32(b'InputChannel') return entity except AttributeError : _raise_cast_fail ( entity , 'InputChannel' ) if isinstance ( entity , ( types . Channel , types . ChannelForbidden )): return types . InputChannel ( entity . id , entity . access_hash or 0 ) if isinstance ( entity , types . InputPeerChannel ): return types . InputChannel ( entity . channel_id , entity . access_hash ) if isinstance ( entity , types . InputPeerChannelFromMessage ): return types . InputChannelFromMessage ( entity . peer , entity . msg_id , entity . channel_id ) _raise_cast_fail ( entity , 'InputChannel' )","title":"get_input_channel()"},{"location":"modules/utils/#telethon.utils.get_input_chat_photo","text":"Similar to :meth: get_input_peer , but for chat photos Source code in telethon\\utils.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def get_input_chat_photo ( photo ): \"\"\"Similar to :meth:`get_input_peer`, but for chat photos\"\"\" try : if photo . SUBCLASS_OF_ID == 0xd4eb2d74 : # crc32(b'InputChatPhoto') return photo elif photo . SUBCLASS_OF_ID == 0xe7655f1f : # crc32(b'InputFile'): return types . InputChatUploadedPhoto ( photo ) except AttributeError : _raise_cast_fail ( photo , 'InputChatPhoto' ) photo = get_input_photo ( photo ) if isinstance ( photo , types . InputPhoto ): return types . InputChatPhoto ( photo ) elif isinstance ( photo , types . InputPhotoEmpty ): return types . InputChatPhotoEmpty () _raise_cast_fail ( photo , 'InputChatPhoto' )","title":"get_input_chat_photo()"},{"location":"modules/utils/#telethon.utils.get_input_dialog","text":"Similar to :meth: get_input_peer , but for dialogs Source code in telethon\\utils.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 def get_input_dialog ( dialog ): \"\"\"Similar to :meth:`get_input_peer`, but for dialogs\"\"\" try : if dialog . SUBCLASS_OF_ID == 0xa21c9795 : # crc32(b'InputDialogPeer') return dialog if dialog . SUBCLASS_OF_ID == 0xc91c90b6 : # crc32(b'InputPeer') return types . InputDialogPeer ( dialog ) except AttributeError : _raise_cast_fail ( dialog , 'InputDialogPeer' ) try : return types . InputDialogPeer ( get_input_peer ( dialog )) except TypeError : pass _raise_cast_fail ( dialog , 'InputDialogPeer' )","title":"get_input_dialog()"},{"location":"modules/utils/#telethon.utils.get_input_document","text":"Similar to :meth: get_input_peer , but for documents Source code in telethon\\utils.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def get_input_document ( document ): \"\"\"Similar to :meth:`get_input_peer`, but for documents\"\"\" try : if document . SUBCLASS_OF_ID == 0xf33fdb68 : # crc32(b'InputDocument'): return document except AttributeError : _raise_cast_fail ( document , 'InputDocument' ) if isinstance ( document , types . Document ): return types . InputDocument ( id = document . id , access_hash = document . access_hash , file_reference = document . file_reference ) if isinstance ( document , types . DocumentEmpty ): return types . InputDocumentEmpty () if isinstance ( document , types . MessageMediaDocument ): return get_input_document ( document . document ) if isinstance ( document , types . Message ): return get_input_document ( document . media ) _raise_cast_fail ( document , 'InputDocument' )","title":"get_input_document()"},{"location":"modules/utils/#telethon.utils.get_input_geo","text":"Similar to :meth: get_input_peer , but for geo points Source code in telethon\\utils.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 def get_input_geo ( geo ): \"\"\"Similar to :meth:`get_input_peer`, but for geo points\"\"\" try : if geo . SUBCLASS_OF_ID == 0x430d225 : # crc32(b'InputGeoPoint'): return geo except AttributeError : _raise_cast_fail ( geo , 'InputGeoPoint' ) if isinstance ( geo , types . GeoPoint ): return types . InputGeoPoint ( lat = geo . lat , long = geo . long ) if isinstance ( geo , types . GeoPointEmpty ): return types . InputGeoPointEmpty () if isinstance ( geo , types . MessageMediaGeo ): return get_input_geo ( geo . geo ) if isinstance ( geo , types . Message ): return get_input_geo ( geo . media ) _raise_cast_fail ( geo , 'InputGeoPoint' )","title":"get_input_geo()"},{"location":"modules/utils/#telethon.utils.get_input_location","text":"Similar to :meth: get_input_peer , but for input messages. Note that this returns a tuple (dc_id, location) , the dc_id being present if known. Source code in telethon\\utils.py 696 697 698 699 700 701 702 703 704 def get_input_location ( location ): \"\"\" Similar to :meth:`get_input_peer`, but for input messages. Note that this returns a tuple ``(dc_id, location)``, the ``dc_id`` being present if known. \"\"\" info = _get_file_info ( location ) return info . dc_id , info . location","title":"get_input_location()"},{"location":"modules/utils/#telethon.utils.get_input_media","text":"Similar to :meth: get_input_peer , but for media. If the media is :tl: InputFile and is_photo is known to be True , it will be treated as an :tl: InputMediaUploadedPhoto . Else, the rest of parameters will indicate how to treat it. Source code in telethon\\utils.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 def get_input_media ( media , * , is_photo = False , attributes = None , force_document = False , voice_note = False , video_note = False , supports_streaming = False ): \"\"\" Similar to :meth:`get_input_peer`, but for media. If the media is :tl:`InputFile` and ``is_photo`` is known to be `True`, it will be treated as an :tl:`InputMediaUploadedPhoto`. Else, the rest of parameters will indicate how to treat it. \"\"\" try : if media . SUBCLASS_OF_ID == 0xfaf846f4 : # crc32(b'InputMedia') return media elif media . SUBCLASS_OF_ID == 0x846363e0 : # crc32(b'InputPhoto') return types . InputMediaPhoto ( media ) elif media . SUBCLASS_OF_ID == 0xf33fdb68 : # crc32(b'InputDocument') return types . InputMediaDocument ( media ) except AttributeError : _raise_cast_fail ( media , 'InputMedia' ) if isinstance ( media , types . MessageMediaPhoto ): return types . InputMediaPhoto ( id = get_input_photo ( media . photo ), ttl_seconds = media . ttl_seconds ) if isinstance ( media , ( types . Photo , types . photos . Photo , types . PhotoEmpty )): return types . InputMediaPhoto ( id = get_input_photo ( media ) ) if isinstance ( media , types . MessageMediaDocument ): return types . InputMediaDocument ( id = get_input_document ( media . document ), ttl_seconds = media . ttl_seconds ) if isinstance ( media , ( types . Document , types . DocumentEmpty )): return types . InputMediaDocument ( id = get_input_document ( media ) ) if isinstance ( media , ( types . InputFile , types . InputFileBig )): if is_photo : return types . InputMediaUploadedPhoto ( file = media ) else : attrs , mime = get_attributes ( media , attributes = attributes , force_document = force_document , voice_note = voice_note , video_note = video_note , supports_streaming = supports_streaming ) return types . InputMediaUploadedDocument ( file = media , mime_type = mime , attributes = attrs ) if isinstance ( media , types . MessageMediaGame ): return types . InputMediaGame ( id = types . InputGameID ( id = media . game . id , access_hash = media . game . access_hash )) if isinstance ( media , types . MessageMediaContact ): return types . InputMediaContact ( phone_number = media . phone_number , first_name = media . first_name , last_name = media . last_name , vcard = '' ) if isinstance ( media , types . MessageMediaGeo ): return types . InputMediaGeoPoint ( geo_point = get_input_geo ( media . geo )) if isinstance ( media , types . MessageMediaVenue ): return types . InputMediaVenue ( geo_point = get_input_geo ( media . geo ), title = media . title , address = media . address , provider = media . provider , venue_id = media . venue_id , venue_type = '' ) if isinstance ( media , types . MessageMediaDice ): return types . InputMediaDice ( media . emoticon ) if isinstance ( media , ( types . MessageMediaEmpty , types . MessageMediaUnsupported , types . ChatPhotoEmpty , types . UserProfilePhotoEmpty , types . ChatPhoto , types . UserProfilePhoto , types . FileLocationToBeDeprecated )): return types . InputMediaEmpty () if isinstance ( media , types . Message ): return get_input_media ( media . media , is_photo = is_photo ) _raise_cast_fail ( media , 'InputMedia' )","title":"get_input_media()"},{"location":"modules/utils/#telethon.utils.get_input_message","text":"Similar to :meth: get_input_peer , but for input messages. Source code in telethon\\utils.py 531 532 533 534 535 536 537 538 539 540 541 542 543 def get_input_message ( message ): \"\"\"Similar to :meth:`get_input_peer`, but for input messages.\"\"\" try : if isinstance ( message , int ): # This case is really common too return types . InputMessageID ( message ) elif message . SUBCLASS_OF_ID == 0x54b6bcc5 : # crc32(b'InputMessage'): return message elif message . SUBCLASS_OF_ID == 0x790009e3 : # crc32(b'Message'): return types . InputMessageID ( message . id ) except AttributeError : pass _raise_cast_fail ( message , 'InputMedia' )","title":"get_input_message()"},{"location":"modules/utils/#telethon.utils.get_input_peer","text":"Gets the input peer for the given \"entity\" (user, chat or channel). A TypeError is raised if the given entity isn't a supported type or if check_hash is True but the entity's access_hash is None or the entity contains min information. In this case, the hash cannot be used for general purposes, and thus is not returned to avoid any issues which can derive from invalid access hashes. Note that check_hash is ignored if an input peer is already passed since in that case we assume the user knows what they're doing. This is key to getting entities by explicitly passing hash = 0 . Source code in telethon\\utils.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def get_input_peer ( entity , allow_self = True , check_hash = True ): \"\"\" Gets the input peer for the given \"entity\" (user, chat or channel). A ``TypeError`` is raised if the given entity isn't a supported type or if ``check_hash is True`` but the entity's ``access_hash is None`` *or* the entity contains ``min`` information. In this case, the hash cannot be used for general purposes, and thus is not returned to avoid any issues which can derive from invalid access hashes. Note that ``check_hash`` **is ignored** if an input peer is already passed since in that case we assume the user knows what they're doing. This is key to getting entities by explicitly passing ``hash = 0``. \"\"\" # NOTE: It is important that this method validates the access hashes, # because it is used when we *require* a valid general-purpose # access hash. This includes caching, which relies on this method. # Further, when resolving raw methods, they do e.g., # utils.get_input_channel(client.get_input_peer(...)) # # ...which means that the client's method verifies the hashes. # # Excerpt from a conversation with official developers (slightly edited): # > We send new access_hash for Channel with min flag since layer 102. # > Previously, we omitted it. # > That one works just to download the profile picture. # # < So, min hashes only work for getting files, # < but the non-min hash is required for any other operation? # # > Yes. # # More information: https://core.telegram.org/api/min try : if entity . SUBCLASS_OF_ID == 0xc91c90b6 : # crc32(b'InputPeer') return entity except AttributeError : # e.g. custom.Dialog (can't cyclic import). if allow_self and hasattr ( entity , 'input_entity' ): return entity . input_entity elif hasattr ( entity , 'entity' ): return get_input_peer ( entity . entity ) else : _raise_cast_fail ( entity , 'InputPeer' ) if isinstance ( entity , types . User ): if entity . is_self and allow_self : return types . InputPeerSelf () elif ( entity . access_hash is not None and not entity . min ) or not check_hash : return types . InputPeerUser ( entity . id , entity . access_hash ) else : raise TypeError ( 'User without access_hash or min info cannot be input' ) if isinstance ( entity , ( types . Chat , types . ChatEmpty , types . ChatForbidden )): return types . InputPeerChat ( entity . id ) if isinstance ( entity , types . Channel ): if ( entity . access_hash is not None and not entity . min ) or not check_hash : return types . InputPeerChannel ( entity . id , entity . access_hash ) else : raise TypeError ( 'Channel without access_hash or min info cannot be input' ) if isinstance ( entity , types . ChannelForbidden ): # \"channelForbidden are never min\", and since their hash is # also not optional, we assume that this truly is the case. return types . InputPeerChannel ( entity . id , entity . access_hash ) if isinstance ( entity , types . InputUser ): return types . InputPeerUser ( entity . user_id , entity . access_hash ) if isinstance ( entity , types . InputChannel ): return types . InputPeerChannel ( entity . channel_id , entity . access_hash ) if isinstance ( entity , types . InputUserSelf ): return types . InputPeerSelf () if isinstance ( entity , types . InputUserFromMessage ): return types . InputPeerUserFromMessage ( entity . peer , entity . msg_id , entity . user_id ) if isinstance ( entity , types . InputChannelFromMessage ): return types . InputPeerChannelFromMessage ( entity . peer , entity . msg_id , entity . channel_id ) if isinstance ( entity , types . UserEmpty ): return types . InputPeerEmpty () if isinstance ( entity , types . UserFull ): return get_input_peer ( entity . user ) if isinstance ( entity , types . ChatFull ): return types . InputPeerChat ( entity . id ) if isinstance ( entity , types . PeerChat ): return types . InputPeerChat ( entity . chat_id ) _raise_cast_fail ( entity , 'InputPeer' )","title":"get_input_peer()"},{"location":"modules/utils/#telethon.utils.get_input_photo","text":"Similar to :meth: get_input_peer , but for photos Source code in telethon\\utils.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def get_input_photo ( photo ): \"\"\"Similar to :meth:`get_input_peer`, but for photos\"\"\" try : if photo . SUBCLASS_OF_ID == 0x846363e0 : # crc32(b'InputPhoto'): return photo except AttributeError : _raise_cast_fail ( photo , 'InputPhoto' ) if isinstance ( photo , types . Message ): photo = photo . media if isinstance ( photo , ( types . photos . Photo , types . MessageMediaPhoto )): photo = photo . photo if isinstance ( photo , types . Photo ): return types . InputPhoto ( id = photo . id , access_hash = photo . access_hash , file_reference = photo . file_reference ) if isinstance ( photo , types . PhotoEmpty ): return types . InputPhotoEmpty () if isinstance ( photo , types . messages . ChatFull ): photo = photo . full_chat if isinstance ( photo , types . ChannelFull ): return get_input_photo ( photo . chat_photo ) elif isinstance ( photo , types . UserFull ): return get_input_photo ( photo . profile_photo ) elif isinstance ( photo , ( types . Channel , types . Chat , types . User )): return get_input_photo ( photo . photo ) if isinstance ( photo , ( types . UserEmpty , types . ChatEmpty , types . ChatForbidden , types . ChannelForbidden )): return types . InputPhotoEmpty () _raise_cast_fail ( photo , 'InputPhoto' )","title":"get_input_photo()"},{"location":"modules/utils/#telethon.utils.get_input_user","text":"Similar to :meth: get_input_peer , but for :tl: InputUser 's alone. .. important:: This method does not validate for invalid general - purpose access hashes , unlike `get_input_peer` . Consider using instead : `` get_input_channel ( get_input_peer ( channel )) `` . Source code in telethon\\utils.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def get_input_user ( entity ): \"\"\" Similar to :meth:`get_input_peer`, but for :tl:`InputUser`'s alone. .. important:: This method does not validate for invalid general-purpose access hashes, unlike `get_input_peer`. Consider using instead: ``get_input_channel(get_input_peer(channel))``. \"\"\" try : if entity . SUBCLASS_OF_ID == 0xe669bf46 : # crc32(b'InputUser'): return entity except AttributeError : _raise_cast_fail ( entity , 'InputUser' ) if isinstance ( entity , types . User ): if entity . is_self : return types . InputUserSelf () else : return types . InputUser ( entity . id , entity . access_hash or 0 ) if isinstance ( entity , types . InputPeerSelf ): return types . InputUserSelf () if isinstance ( entity , ( types . UserEmpty , types . InputPeerEmpty )): return types . InputUserEmpty () if isinstance ( entity , types . UserFull ): return get_input_user ( entity . user ) if isinstance ( entity , types . InputPeerUser ): return types . InputUser ( entity . user_id , entity . access_hash ) if isinstance ( entity , types . InputPeerUserFromMessage ): return types . InputUserFromMessage ( entity . peer , entity . msg_id , entity . user_id ) _raise_cast_fail ( entity , 'InputUser' )","title":"get_input_user()"},{"location":"modules/utils/#telethon.utils.get_message_id","text":"Similar to :meth: get_input_peer , but for message IDs. Source code in telethon\\utils.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def get_message_id ( message ): \"\"\"Similar to :meth:`get_input_peer`, but for message IDs.\"\"\" if message is None : return None if isinstance ( message , int ): return message try : if message . SUBCLASS_OF_ID == 0x790009e3 : # hex(crc32(b'Message')) = 0x790009e3 return message . id except AttributeError : pass raise TypeError ( 'Invalid message type: {} ' . format ( type ( message )))","title":"get_message_id()"},{"location":"modules/utils/#telethon.utils.get_peer_id","text":"Convert the given peer into its marked ID by default. This \"mark\" comes from the \"bot api\" format, and with it the peer type can be identified back. User ID is left unmodified, chat ID is negated, and channel ID is prefixed with -100: user_id -chat_id -100channel_id The original ID and the peer type class can be returned with a call to :meth: resolve_id(marked_id) . Source code in telethon\\utils.py 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 def get_peer_id ( peer , add_mark = True ): \"\"\" Convert the given peer into its marked ID by default. This \"mark\" comes from the \"bot api\" format, and with it the peer type can be identified back. User ID is left unmodified, chat ID is negated, and channel ID is prefixed with -100: * ``user_id`` * ``-chat_id`` * ``-100channel_id`` The original ID and the peer type class can be returned with a call to :meth:`resolve_id(marked_id)`. \"\"\" # First we assert it's a Peer TLObject, or early return for integers if isinstance ( peer , int ): return peer if add_mark else resolve_id ( peer )[ 0 ] # Tell the user to use their client to resolve InputPeerSelf if we got one if isinstance ( peer , types . InputPeerSelf ): _raise_cast_fail ( peer , 'int (you might want to use client.get_peer_id)' ) try : peer = get_peer ( peer ) except TypeError : _raise_cast_fail ( peer , 'int' ) if isinstance ( peer , types . PeerUser ): return peer . user_id elif isinstance ( peer , types . PeerChat ): # Check in case the user mixed things up to avoid blowing up if not ( 0 < peer . chat_id <= 0x7fffffff ): peer . chat_id = resolve_id ( peer . chat_id )[ 0 ] return - peer . chat_id if add_mark else peer . chat_id else : # if isinstance(peer, types.PeerChannel): # Check in case the user mixed things up to avoid blowing up if not ( 0 < peer . channel_id <= 0x7fffffff ): peer . channel_id = resolve_id ( peer . channel_id )[ 0 ] if not add_mark : return peer . channel_id # Concat -100 through math tricks, .to_supergroup() on # Madeline IDs will be strictly positive -> log works. try : return - ( peer . channel_id + pow ( 10 , math . floor ( math . log10 ( peer . channel_id ) + 3 ))) except ValueError : raise TypeError ( 'Cannot get marked ID of a channel ' 'unless its ID is strictly positive' ) from None","title":"get_peer_id()"},{"location":"modules/utils/#telethon.utils.is_audio","text":"Returns True if the file extension looks like an audio file. Source code in telethon\\utils.py 784 785 786 787 def is_audio ( file ): \"\"\"Returns `True` if the file extension looks like an audio file.\"\"\" file = 'a' + _get_extension ( file ) return ( mimetypes . guess_type ( file )[ 0 ] or '' ) . startswith ( 'audio/' )","title":"is_audio()"},{"location":"modules/utils/#telethon.utils.is_gif","text":"Returns True if the file extension looks like a gif file to Telegram. Source code in telethon\\utils.py 777 778 779 780 781 def is_gif ( file ): \"\"\" Returns `True` if the file extension looks like a gif file to Telegram. \"\"\" return re . match ( r '\\.gif' , _get_extension ( file ), re . IGNORECASE )","title":"is_gif()"},{"location":"modules/utils/#telethon.utils.is_image","text":"Returns True if the file extension looks like an image file to Telegram. Source code in telethon\\utils.py 766 767 768 769 770 771 772 773 774 def is_image ( file ): \"\"\" Returns `True` if the file extension looks like an image file to Telegram. \"\"\" match = re . match ( r '\\.(png|jpe?g)' , _get_extension ( file ), re . IGNORECASE ) if match : return True else : return isinstance ( resolve_bot_file_id ( file ), types . Photo )","title":"is_image()"},{"location":"modules/utils/#telethon.utils.is_list_like","text":"Returns True if the given object looks like a list. Checking if hasattr(obj, '__iter__') and ignoring str/bytes is not enough. Things like open() are also iterable (and probably many other things), so just support the commonly known list-like objects. Source code in telethon\\utils.py 796 797 798 799 800 801 802 803 804 def is_list_like ( obj ): \"\"\" Returns `True` if the given object looks like a list. Checking ``if hasattr(obj, '__iter__')`` and ignoring ``str/bytes`` is not enough. Things like ``open()`` are also iterable (and probably many other things), so just support the commonly known list-like objects. \"\"\" return isinstance ( obj , ( list , tuple , set , dict , GeneratorType ))","title":"is_list_like()"},{"location":"modules/utils/#telethon.utils.is_video","text":"Returns True if the file extension looks like a video file. Source code in telethon\\utils.py 790 791 792 793 def is_video ( file ): \"\"\"Returns `True` if the file extension looks like a video file.\"\"\" file = 'a' + _get_extension ( file ) return ( mimetypes . guess_type ( file )[ 0 ] or '' ) . startswith ( 'video/' )","title":"is_video()"},{"location":"modules/utils/#telethon.utils.pack_bot_file_id","text":"Inverse operation for resolve_bot_file_id . The only parameters this method will accept are :tl: Document and :tl: Photo , and it will return a variable-length file_id string. If an invalid parameter is given, it will return None . Source code in telethon\\utils.py 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 def pack_bot_file_id ( file ): \"\"\" Inverse operation for `resolve_bot_file_id`. The only parameters this method will accept are :tl:`Document` and :tl:`Photo`, and it will return a variable-length ``file_id`` string. If an invalid parameter is given, it will ``return None``. \"\"\" if isinstance ( file , types . MessageMediaDocument ): file = file . document elif isinstance ( file , types . MessageMediaPhoto ): file = file . photo if isinstance ( file , types . Document ): file_type = 5 for attribute in file . attributes : if isinstance ( attribute , types . DocumentAttributeAudio ): file_type = 3 if attribute . voice else 9 elif isinstance ( attribute , types . DocumentAttributeVideo ): file_type = 13 if attribute . round_message else 4 elif isinstance ( attribute , types . DocumentAttributeSticker ): file_type = 8 elif isinstance ( attribute , types . DocumentAttributeAnimated ): file_type = 10 else : continue break return _encode_telegram_base64 ( _rle_encode ( struct . pack ( '<iiqqb' , file_type , file . dc_id , file . id , file . access_hash , 2 ))) elif isinstance ( file , types . Photo ): size = next (( x for x in reversed ( file . sizes ) if isinstance ( x , ( types . PhotoSize , types . PhotoCachedSize ))), None ) if not size : return None size = size . location return _encode_telegram_base64 ( _rle_encode ( struct . pack ( '<iiqqqqib' , 2 , file . dc_id , file . id , file . access_hash , size . volume_id , 0 , size . local_id , 2 # 0 = old `secret` ))) else : return None","title":"pack_bot_file_id()"},{"location":"modules/utils/#telethon.utils.parse_phone","text":"Parses the given phone, or returns None if it's invalid. Source code in telethon\\utils.py 807 808 809 810 811 812 813 814 def parse_phone ( phone ): \"\"\"Parses the given phone, or returns `None` if it's invalid.\"\"\" if isinstance ( phone , int ): return str ( phone ) else : phone = re . sub ( r '[+()\\s-]' , '' , str ( phone )) if phone . isdigit (): return phone","title":"parse_phone()"},{"location":"modules/utils/#telethon.utils.parse_username","text":"Parses the given username or channel access hash, given a string, username or URL. Returns a tuple consisting of both the stripped, lowercase username and whether it is a joinchat/ hash (in which case is not lowercase'd). Returns (None, False) if the username or link is not valid. Source code in telethon\\utils.py 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 def parse_username ( username ): \"\"\" Parses the given username or channel access hash, given a string, username or URL. Returns a tuple consisting of both the stripped, lowercase username and whether it is a joinchat/ hash (in which case is not lowercase'd). Returns ``(None, False)`` if the ``username`` or link is not valid. \"\"\" username = username . strip () m = USERNAME_RE . match ( username ) or TG_JOIN_RE . match ( username ) if m : username = username [ m . end ():] is_invite = bool ( m . group ( 1 )) if is_invite : return username , True else : username = username . rstrip ( '/' ) if VALID_USERNAME_RE . match ( username ): return username . lower (), False else : return None , False","title":"parse_username()"},{"location":"modules/utils/#telethon.utils.resolve_bot_file_id","text":"Given a Bot API-style file_id <telethon.tl.custom.file.File.id> , returns the media it represents. If the file_id <telethon.tl.custom.file.File.id> is not valid, None is returned instead. Note that the file_id <telethon.tl.custom.file.File.id> does not have information such as image dimensions or file size, so these will be zero if present. For thumbnails, the photo ID and hash will always be zero. Source code in telethon\\utils.py 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 def resolve_bot_file_id ( file_id ): \"\"\" Given a Bot API-style `file_id <telethon.tl.custom.file.File.id>`, returns the media it represents. If the `file_id <telethon.tl.custom.file.File.id>` is not valid, `None` is returned instead. Note that the `file_id <telethon.tl.custom.file.File.id>` does not have information such as image dimensions or file size, so these will be zero if present. For thumbnails, the photo ID and hash will always be zero. \"\"\" data = _rle_decode ( _decode_telegram_base64 ( file_id )) if not data : return None # This isn't officially documented anywhere, but # we assume the last byte is some kind of \"version\". data , version = data [: - 1 ], data [ - 1 ] if version not in ( 2 , 4 ): return None if ( version == 2 and len ( data ) == 24 ) or ( version == 4 and len ( data ) == 25 ): if version == 2 : file_type , dc_id , media_id , access_hash = struct . unpack ( '<iiqq' , data ) # elif version == 4: else : # TODO Figure out what the extra byte means file_type , dc_id , media_id , access_hash , _ = struct . unpack ( '<iiqqb' , data ) if not ( 1 <= dc_id <= 5 ): # Valid `file_id`'s must have valid DC IDs. Since this method is # called when sending a file and the user may have entered a path # they believe is correct but the file doesn't exist, this method # may detect a path as \"valid\" bot `file_id` even when it's not. # By checking the `dc_id`, we greatly reduce the chances of this # happening. return None attributes = [] if file_type == 3 or file_type == 9 : attributes . append ( types . DocumentAttributeAudio ( duration = 0 , voice = file_type == 3 )) elif file_type == 4 or file_type == 13 : attributes . append ( types . DocumentAttributeVideo ( duration = 0 , w = 0 , h = 0 , round_message = file_type == 13 )) # elif file_type == 5: # other, cannot know which elif file_type == 8 : attributes . append ( types . DocumentAttributeSticker ( alt = '' , stickerset = types . InputStickerSetEmpty () )) elif file_type == 10 : attributes . append ( types . DocumentAttributeAnimated ()) return types . Document ( id = media_id , access_hash = access_hash , date = None , mime_type = '' , size = 0 , thumbs = None , dc_id = dc_id , attributes = attributes , file_reference = b '' ) elif ( version == 2 and len ( data ) == 44 ) or ( version == 4 and len ( data ) == 49 ): if version == 2 : ( file_type , dc_id , media_id , access_hash , volume_id , secret , local_id ) = struct . unpack ( '<iiqqqqi' , data ) # elif version == 4: else : # TODO Figure out what the extra five bytes mean ( file_type , dc_id , media_id , access_hash , volume_id , secret , local_id , _ ) = struct . unpack ( '<iiqqqqi5s' , data ) if not ( 1 <= dc_id <= 5 ): return None # Thumbnails (small) always have ID 0; otherwise size 'x' photo_size = 's' if media_id or access_hash else 'x' return types . Photo ( id = media_id , access_hash = access_hash , file_reference = b '' , date = None , sizes = [ types . PhotoSize ( type = photo_size , location = types . FileLocationToBeDeprecated ( volume_id = volume_id , local_id = local_id ), w = 0 , h = 0 , size = 0 )], dc_id = dc_id , has_stickers = None )","title":"resolve_bot_file_id()"},{"location":"modules/utils/#telethon.utils.resolve_id","text":"Given a marked ID, returns the original ID and its :tl: Peer type. Source code in telethon\\utils.py 948 949 950 951 952 953 954 955 956 957 958 959 960 961 def resolve_id ( marked_id ): \"\"\"Given a marked ID, returns the original ID and its :tl:`Peer` type.\"\"\" if marked_id >= 0 : return marked_id , types . PeerUser # There have been report of chat IDs being 10000xyz, which means their # marked version is -10000xyz, which in turn looks like a channel but # it becomes 00xyz (= xyz). Hence, we must assert that there are only # two zeroes. m = re . match ( r '-100([^0]\\d*)' , str ( marked_id )) if m : return int ( m . group ( 1 )), types . PeerChannel return - marked_id , types . PeerChat","title":"resolve_id()"},{"location":"modules/utils/#telethon.utils.resolve_inline_message_id","text":"Resolves an inline message ID. Returns a tuple of (message id, peer, dc id, access hash) The peer may either be a :tl: PeerUser referencing the user who sent the message via the bot in a private conversation or small group chat, or a :tl: PeerChannel if the message was sent in a channel. The access_hash does not have any use yet. Source code in telethon\\utils.py 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 def resolve_inline_message_id ( inline_msg_id ): \"\"\" Resolves an inline message ID. Returns a tuple of ``(message id, peer, dc id, access hash)`` The ``peer`` may either be a :tl:`PeerUser` referencing the user who sent the message via the bot in a private conversation or small group chat, or a :tl:`PeerChannel` if the message was sent in a channel. The ``access_hash`` does not have any use yet. \"\"\" try : dc_id , message_id , pid , access_hash = \\ struct . unpack ( '<iiiq' , _decode_telegram_base64 ( inline_msg_id )) peer = types . PeerChannel ( - pid ) if pid < 0 else types . PeerUser ( pid ) return message_id , peer , dc_id , access_hash except ( struct . error , TypeError ): return None , None , None , None","title":"resolve_inline_message_id()"},{"location":"modules/utils/#telethon.utils.resolve_invite_link","text":"Resolves the given invite link. Returns a tuple of (link creator user id, global chat id, random int) . Note that for broadcast channels, the link creator user ID will be zero to protect their identity. Normal chats and megagroup channels will have such ID. Note that the chat ID may not be accurate for chats with a link that were upgraded to megagroup, since the link can remain the same, but the chat ID will be correct once a new link is generated. Source code in telethon\\utils.py 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 def resolve_invite_link ( link ): \"\"\" Resolves the given invite link. Returns a tuple of ``(link creator user id, global chat id, random int)``. Note that for broadcast channels, the link creator user ID will be zero to protect their identity. Normal chats and megagroup channels will have such ID. Note that the chat ID may not be accurate for chats with a link that were upgraded to megagroup, since the link can remain the same, but the chat ID will be correct once a new link is generated. \"\"\" link_hash , is_link = parse_username ( link ) if not is_link : # Perhaps the user passed the link hash directly link_hash = link # Little known fact, but invite links with a # hex-string of bytes instead of base64 also works. if re . match ( r '[a-fA-F\\d] {32} ' , link_hash ): payload = bytes . fromhex ( link_hash ) else : payload = _decode_telegram_base64 ( link_hash ) try : return struct . unpack ( '>LLQ' , payload ) except ( struct . error , TypeError ): return None , None , None","title":"resolve_invite_link()"},{"location":"modules/utils/#telethon.utils.sanitize_parse_mode","text":"Converts the given parse mode into an object with parse and unparse callable properties. Source code in telethon\\utils.py 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 def sanitize_parse_mode ( mode ): \"\"\" Converts the given parse mode into an object with ``parse`` and ``unparse`` callable properties. \"\"\" if not mode : return None if callable ( mode ): class CustomMode : @staticmethod def unparse ( text , entities ): raise NotImplementedError CustomMode . parse = mode return CustomMode elif ( all ( hasattr ( mode , x ) for x in ( 'parse' , 'unparse' )) and all ( callable ( x ) for x in ( mode . parse , mode . unparse ))): return mode elif isinstance ( mode , str ): try : return { 'md' : markdown , 'markdown' : markdown , 'htm' : html , 'html' : html }[ mode . lower ()] except KeyError : raise ValueError ( 'Unknown parse mode {} ' . format ( mode )) else : raise TypeError ( 'Invalid parse mode type {} ' . format ( mode ))","title":"sanitize_parse_mode()"},{"location":"modules/utils/#telethon.utils.stripped_photo_to_jpg","text":"Adds the JPG header and footer to a stripped image. Ported from https://github.com/telegramdesktop/tdesktop/blob/bec39d89e19670eb436dc794a8f20b657cb87c71/Telegram/SourceFiles/ui/image/image.cpp#L225 Source code in telethon\\utils.py 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 def stripped_photo_to_jpg ( stripped ): \"\"\" Adds the JPG header and footer to a stripped image. Ported from https://github.com/telegramdesktop/tdesktop/blob/bec39d89e19670eb436dc794a8f20b657cb87c71/Telegram/SourceFiles/ui/image/image.cpp#L225 \"\"\" # NOTE: Changes here should update _photo_size_byte_count if len ( stripped ) < 3 or stripped [ 0 ] != 1 : return stripped header = bytearray ( b ' \\xff\\xd8\\xff\\xe0\\x00\\x10 JFIF \\x00\\x01\\x01\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\xff\\xdb\\x00 C \\x00 ( \\x1c\\x1e # \\x1e\\x19 (#!#-+(0<dA<77<{X]Id \\x91\\x80\\x99\\x96\\x8f\\x80\\x8c\\x8a\\xa0\\xb4\\xe6\\xc3\\xa0\\xaa\\xda\\xad\\x8a\\x8c\\xc8\\xff\\xcb\\xda\\xee\\xf5\\xff\\xff\\xff\\x9b\\xc1\\xff\\xff\\xff\\xfa\\xff\\xe6\\xfd\\xff\\xf8\\xff\\xdb\\x00 C \\x01 +--<5<vAAv \\xf8\\xa5\\x8c\\xa5\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xf8\\xff\\xc0\\x00\\x11\\x08\\x00\\x00\\x00\\x00\\x03\\x01 \" \\x00\\x02\\x11\\x01\\x03\\x11\\x01\\xff\\xc4\\x00\\x1f\\x00\\x00\\x01\\x05\\x01\\x01\\x01\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\xff\\xc4\\x00\\xb5\\x10\\x00\\x02\\x01\\x03\\x03\\x02\\x04\\x03\\x05\\x05\\x04\\x04\\x00\\x00\\x01 } \\x01\\x02\\x03\\x00\\x04\\x11\\x05\\x12 !1A \\x06\\x13 Qa \\x07 \"q \\x14 2 \\x81\\x91\\xa1\\x08 #B \\xb1\\xc1\\x15 R \\xd1\\xf0 $3br \\x82\\t\\n\\x16\\x17\\x18\\x19\\x1a %& \\' ()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz \\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xff\\xc4\\x00\\x1f\\x01\\x00\\x03\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\xff\\xc4\\x00\\xb5\\x11\\x00\\x02\\x01\\x02\\x04\\x04\\x03\\x04\\x07\\x05\\x04\\x04\\x00\\x01\\x02 w \\x00\\x01\\x02\\x03\\x11\\x04\\x05 !1 \\x06\\x12 AQ \\x07 aq \\x13 \"2 \\x81\\x08\\x14 B \\x91\\xa1\\xb1\\xc1\\t #3R \\xf0\\x15 br \\xd1\\n\\x16 $4 \\xe1 % \\xf1\\x17\\x18\\x19\\x1a & \\' ()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz \\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xff\\xda\\x00\\x0c\\x03\\x01\\x00\\x02\\x11\\x03\\x11\\x00 ? \\x00 ' ) footer = b \" \\xff\\xd9 \" header [ 164 ] = stripped [ 1 ] header [ 166 ] = stripped [ 2 ] return bytes ( header ) + stripped [ 3 :] + footer","title":"stripped_photo_to_jpg()"},{"location":"quick-references/client-reference/","text":"Client Reference \u00b6 This page contains a summary of all the important methods and properties that you may need when using Telethon. They are sorted by relevance and are not in alphabetical order. You should use this page to learn about which methods are available, and if you need an usage example or further description of the arguments, be sure to follow the links. TelegramClient \u00b6 This is a summary of the methods and properties you will find at :ref: telethon-client . Auth \u00b6 .. currentmodule:: telethon.client.auth.AuthMethods .. autosummary:: :nosignatures: start send_code_request sign_in sign_up log_out edit_2fa Base \u00b6 .. py:currentmodule:: telethon.client.telegrambaseclient.TelegramBaseClient .. autosummary:: :nosignatures: connect disconnect is_connected disconnected loop Messages \u00b6 .. py:currentmodule:: telethon.client.messages.MessageMethods .. autosummary:: :nosignatures: send_message edit_message delete_messages forward_messages iter_messages get_messages pin_message send_read_acknowledge Uploads \u00b6 .. py:currentmodule:: telethon.client.uploads.UploadMethods .. autosummary:: :nosignatures: send_file upload_file Downloads \u00b6 .. currentmodule:: telethon.client.downloads.DownloadMethods .. autosummary:: :nosignatures: download_media download_profile_photo download_file iter_download Dialogs \u00b6 .. py:currentmodule:: telethon.client.dialogs.DialogMethods .. autosummary:: :nosignatures: iter_dialogs get_dialogs edit_folder iter_drafts get_drafts delete_dialog conversation Users \u00b6 .. py:currentmodule:: telethon.client.users.UserMethods .. autosummary:: :nosignatures: get_me is_bot is_user_authorized get_entity get_input_entity get_peer_id Chats \u00b6 .. currentmodule:: telethon.client.chats.ChatMethods .. autosummary:: :nosignatures: iter_participants get_participants kick_participant iter_admin_log get_admin_log iter_profile_photos get_profile_photos edit_admin edit_permissions action Parse Mode \u00b6 .. py:currentmodule:: telethon.client.messageparse.MessageParseMethods .. autosummary:: :nosignatures: parse_mode Updates \u00b6 .. py:currentmodule:: telethon.client.updates.UpdateMethods .. autosummary:: :nosignatures: on run_until_disconnected add_event_handler remove_event_handler list_event_handlers catch_up Bots \u00b6 .. currentmodule:: telethon.client.bots.BotMethods .. autosummary:: :nosignatures: inline_query Buttons \u00b6 .. currentmodule:: telethon.client.buttons.ButtonMethods .. autosummary:: :nosignatures: build_reply_markup Account \u00b6 .. currentmodule:: telethon.client.account.AccountMethods .. autosummary:: :nosignatures: takeout end_takeout","title":"Client Reference"},{"location":"quick-references/client-reference/#client-reference","text":"This page contains a summary of all the important methods and properties that you may need when using Telethon. They are sorted by relevance and are not in alphabetical order. You should use this page to learn about which methods are available, and if you need an usage example or further description of the arguments, be sure to follow the links.","title":"Client Reference"},{"location":"quick-references/client-reference/#telegramclient","text":"This is a summary of the methods and properties you will find at :ref: telethon-client .","title":"TelegramClient"},{"location":"quick-references/client-reference/#auth","text":".. currentmodule:: telethon.client.auth.AuthMethods .. autosummary:: :nosignatures: start send_code_request sign_in sign_up log_out edit_2fa","title":"Auth"},{"location":"quick-references/client-reference/#base","text":".. py:currentmodule:: telethon.client.telegrambaseclient.TelegramBaseClient .. autosummary:: :nosignatures: connect disconnect is_connected disconnected loop","title":"Base"},{"location":"quick-references/client-reference/#messages","text":".. py:currentmodule:: telethon.client.messages.MessageMethods .. autosummary:: :nosignatures: send_message edit_message delete_messages forward_messages iter_messages get_messages pin_message send_read_acknowledge","title":"Messages"},{"location":"quick-references/client-reference/#uploads","text":".. py:currentmodule:: telethon.client.uploads.UploadMethods .. autosummary:: :nosignatures: send_file upload_file","title":"Uploads"},{"location":"quick-references/client-reference/#downloads","text":".. currentmodule:: telethon.client.downloads.DownloadMethods .. autosummary:: :nosignatures: download_media download_profile_photo download_file iter_download","title":"Downloads"},{"location":"quick-references/client-reference/#dialogs","text":".. py:currentmodule:: telethon.client.dialogs.DialogMethods .. autosummary:: :nosignatures: iter_dialogs get_dialogs edit_folder iter_drafts get_drafts delete_dialog conversation","title":"Dialogs"},{"location":"quick-references/client-reference/#users","text":".. py:currentmodule:: telethon.client.users.UserMethods .. autosummary:: :nosignatures: get_me is_bot is_user_authorized get_entity get_input_entity get_peer_id","title":"Users"},{"location":"quick-references/client-reference/#chats","text":".. currentmodule:: telethon.client.chats.ChatMethods .. autosummary:: :nosignatures: iter_participants get_participants kick_participant iter_admin_log get_admin_log iter_profile_photos get_profile_photos edit_admin edit_permissions action","title":"Chats"},{"location":"quick-references/client-reference/#parse-mode","text":".. py:currentmodule:: telethon.client.messageparse.MessageParseMethods .. autosummary:: :nosignatures: parse_mode","title":"Parse Mode"},{"location":"quick-references/client-reference/#updates","text":".. py:currentmodule:: telethon.client.updates.UpdateMethods .. autosummary:: :nosignatures: on run_until_disconnected add_event_handler remove_event_handler list_event_handlers catch_up","title":"Updates"},{"location":"quick-references/client-reference/#bots","text":".. currentmodule:: telethon.client.bots.BotMethods .. autosummary:: :nosignatures: inline_query","title":"Bots"},{"location":"quick-references/client-reference/#buttons","text":".. currentmodule:: telethon.client.buttons.ButtonMethods .. autosummary:: :nosignatures: build_reply_markup","title":"Buttons"},{"location":"quick-references/client-reference/#account","text":".. currentmodule:: telethon.client.account.AccountMethods .. autosummary:: :nosignatures: takeout end_takeout","title":"Account"},{"location":"quick-references/faq/","text":"FAQ \u00b6 Let's start the quick references section with some useful tips to keep in mind, with the hope that you will understand why certain things work the way that they do. Code without errors doesn't work \u00b6 Then it probably has errors, but you haven't enabled logging yet. To enable logging, at the following code to the top of your main file: import logging logging . basicConfig ( format = '[ %(levelname) 5s / %(asctime)s ] %(name)s : %(message)s ' , level = logging . WARNING ) You can change the logging level to be something different, from less to more information: level = logging . CRITICAL # won't show errors (same as disabled) level = logging . ERROR # will only show errors that you didn't handle level = logging . WARNING # will also show messages with medium severity, such as internal Telegram issues level = logging . INFO # will also show informational messages, such as connection or disconnections level = logging . DEBUG # will show a lot of output to help debugging issues in the library See the official Python documentation for more information on logging_. How can I except FloodWaitError? \u00b6 You can use all errors from the API by importing: from telethon import errors And except them as such: try : await client . send_message ( chat , 'Hi' ) except errors . FloodWaitError as e : # e.seconds is how many seconds you have # to wait before making the request again. print ( 'Flood for' , e . seconds ) My account was deleted/limited when using the library \u00b6 The library will only do things that you tell it to do. If you use the library with bad intentions, Telegram will hopefully ban you. However, you may also be part of a limited country, such as Iran or Russia. In that case, we have bad news for you. Telegram is much more likely to ban these numbers, as they are often used to spam other accounts, likely through the use of libraries like this one. The best advice we can give you is to not abuse the API, like calling many requests really quickly, and to sign up with these phones through an official application. We have also had reports from Kazakhstan and China, where connecting would fail. To solve these connection problems, you should use a proxy. Telegram may also ban virtual (VoIP) phone numbers, as again, they're likely to be used for spam. If you want to check if your account has been limited, simply send a private message to @SpamBot through Telegram itself. You should notice this by getting errors like PeerFloodError , which means you're limited, for instance, when sending a message to some accounts but not others. For more discussion, please see issue 297 . How can I use a proxy? \u00b6 This was one of the first things described in :ref: signing-in . How do I access a field? \u00b6 This is basic Python knowledge. You should use the dot operator: me = await client . get_me () print ( me . username ) # ^ we used the dot operator to access the username attribute result = await client ( functions . photos . GetUserPhotosRequest ( user_id = 'me' , offset = 0 , max_id = 0 , limit = 100 )) # Working with list is also pretty basic print ( result . photos [ 0 ] . sizes [ - 1 ] . type ) # ^ ^ ^ ^ ^ # | | | | \\ type # | | | \\ last size # | | \\ list of sizes # access | \\ first photo from the list # the... \\ list of photos # # To print all, you could do (or mix-and-match): for photo in result . photos : for size in photo . sizes : print ( size . type ) AttributeError: 'coroutine' object has no attribute 'id' \u00b6 You either forgot to: import telethon.sync # ^^^^^ import sync Or: async def handler ( event ): me = await client . get_me () # ^^^^^ note the await print ( me . username ) sqlite3.OperationalError: database is locked \u00b6 An older process is still running and is using the same 'session' file. This error occurs when two or more clients use the same session , that is, when you write the same session name to be used in the client: You have an older process using the same session file. You have two different scripts running (interactive sessions count too). You have two clients in the same script running at the same time. The solution is, if you need two clients, use two sessions. If the problem persists and you're on Linux, you can use fuser my.session to find out the process locking the file. As a last resort, you can reboot your system. If you really dislike SQLite, use a different session storage. There is an entire section covering that at :ref: sessions . event.chat or event.sender is None \u00b6 Telegram doesn't always send this information in order to save bandwidth. If you need the information, you should fetch it yourself, since the library won't do unnecessary work unless you need to: async def handler ( event ): chat = await event . get_chat () sender = await event . get_sender () What does bases ChatGetter mean? \u00b6 In Python, classes can base others. This is called inheritance <https://ddg.gg/python%20inheritance> _. What it means is that \"if a class bases another, you can use the other's methods too\". For example, Message <telethon.tl.custom.message.Message> bases ChatGetter <telethon.tl.custom.chatgetter.ChatGetter> . In turn, ChatGetter <telethon.tl.custom.chatgetter.ChatGetter> defines things like obj.chat_id <telethon.tl.custom.chatgetter.ChatGetter> . So if you have a message, you can access that too: # ChatGetter has a chat_id property, and Message bases ChatGetter. # Thus you can use ChatGetter properties and methods from Message print ( message . chat_id ) Telegram has a lot to offer, and inheritance helps the library reduce boilerplate, so it's important to know this concept. For newcomers, this may be a problem, so we explain what it means here in the FAQ. Can I use Flask with the library? \u00b6 Yes, if you know what you are doing. However, you will probably have a lot of headaches to get threads and asyncio to work together. Instead, consider using Quart , an asyncio-based alternative to Flask . Check out quart_login.py for an example web-application based on Quart. Can I use Anaconda/Spyder/IPython with the library? \u00b6 Yes, but these interpreters run the asyncio event loop implicitly, which interferes with the telethon.sync magic module. If you use them, you should not import sync : # Change any of these...: from telethon import TelegramClient , sync , ... from telethon.sync import TelegramClient , ... # ...with this: from telethon import TelegramClient , ... You are also more likely to get \"sqlite3.OperationalError: database is locked\" with them. If they cause too much trouble, just write your code in a .py file and run that, or use the normal python interpreter.","title":"FAQ"},{"location":"quick-references/faq/#faq","text":"Let's start the quick references section with some useful tips to keep in mind, with the hope that you will understand why certain things work the way that they do.","title":"FAQ"},{"location":"quick-references/faq/#code-without-errors-doesnt-work","text":"Then it probably has errors, but you haven't enabled logging yet. To enable logging, at the following code to the top of your main file: import logging logging . basicConfig ( format = '[ %(levelname) 5s / %(asctime)s ] %(name)s : %(message)s ' , level = logging . WARNING ) You can change the logging level to be something different, from less to more information: level = logging . CRITICAL # won't show errors (same as disabled) level = logging . ERROR # will only show errors that you didn't handle level = logging . WARNING # will also show messages with medium severity, such as internal Telegram issues level = logging . INFO # will also show informational messages, such as connection or disconnections level = logging . DEBUG # will show a lot of output to help debugging issues in the library See the official Python documentation for more information on logging_.","title":"Code without errors doesn't work"},{"location":"quick-references/faq/#how-can-i-except-floodwaiterror","text":"You can use all errors from the API by importing: from telethon import errors And except them as such: try : await client . send_message ( chat , 'Hi' ) except errors . FloodWaitError as e : # e.seconds is how many seconds you have # to wait before making the request again. print ( 'Flood for' , e . seconds )","title":"How can I except FloodWaitError?"},{"location":"quick-references/faq/#my-account-was-deletedlimited-when-using-the-library","text":"The library will only do things that you tell it to do. If you use the library with bad intentions, Telegram will hopefully ban you. However, you may also be part of a limited country, such as Iran or Russia. In that case, we have bad news for you. Telegram is much more likely to ban these numbers, as they are often used to spam other accounts, likely through the use of libraries like this one. The best advice we can give you is to not abuse the API, like calling many requests really quickly, and to sign up with these phones through an official application. We have also had reports from Kazakhstan and China, where connecting would fail. To solve these connection problems, you should use a proxy. Telegram may also ban virtual (VoIP) phone numbers, as again, they're likely to be used for spam. If you want to check if your account has been limited, simply send a private message to @SpamBot through Telegram itself. You should notice this by getting errors like PeerFloodError , which means you're limited, for instance, when sending a message to some accounts but not others. For more discussion, please see issue 297 .","title":"My account was deleted/limited when using the library"},{"location":"quick-references/faq/#how-can-i-use-a-proxy","text":"This was one of the first things described in :ref: signing-in .","title":"How can I use a proxy?"},{"location":"quick-references/faq/#how-do-i-access-a-field","text":"This is basic Python knowledge. You should use the dot operator: me = await client . get_me () print ( me . username ) # ^ we used the dot operator to access the username attribute result = await client ( functions . photos . GetUserPhotosRequest ( user_id = 'me' , offset = 0 , max_id = 0 , limit = 100 )) # Working with list is also pretty basic print ( result . photos [ 0 ] . sizes [ - 1 ] . type ) # ^ ^ ^ ^ ^ # | | | | \\ type # | | | \\ last size # | | \\ list of sizes # access | \\ first photo from the list # the... \\ list of photos # # To print all, you could do (or mix-and-match): for photo in result . photos : for size in photo . sizes : print ( size . type )","title":"How do I access a field?"},{"location":"quick-references/faq/#attributeerror-coroutine-object-has-no-attribute-id","text":"You either forgot to: import telethon.sync # ^^^^^ import sync Or: async def handler ( event ): me = await client . get_me () # ^^^^^ note the await print ( me . username )","title":"AttributeError: 'coroutine' object has no attribute 'id'"},{"location":"quick-references/faq/#sqlite3operationalerror-database-is-locked","text":"An older process is still running and is using the same 'session' file. This error occurs when two or more clients use the same session , that is, when you write the same session name to be used in the client: You have an older process using the same session file. You have two different scripts running (interactive sessions count too). You have two clients in the same script running at the same time. The solution is, if you need two clients, use two sessions. If the problem persists and you're on Linux, you can use fuser my.session to find out the process locking the file. As a last resort, you can reboot your system. If you really dislike SQLite, use a different session storage. There is an entire section covering that at :ref: sessions .","title":"sqlite3.OperationalError: database is locked"},{"location":"quick-references/faq/#eventchat-or-eventsender-is-none","text":"Telegram doesn't always send this information in order to save bandwidth. If you need the information, you should fetch it yourself, since the library won't do unnecessary work unless you need to: async def handler ( event ): chat = await event . get_chat () sender = await event . get_sender ()","title":"event.chat or event.sender is None"},{"location":"quick-references/faq/#what-does-bases-chatgetter-mean","text":"In Python, classes can base others. This is called inheritance <https://ddg.gg/python%20inheritance> _. What it means is that \"if a class bases another, you can use the other's methods too\". For example, Message <telethon.tl.custom.message.Message> bases ChatGetter <telethon.tl.custom.chatgetter.ChatGetter> . In turn, ChatGetter <telethon.tl.custom.chatgetter.ChatGetter> defines things like obj.chat_id <telethon.tl.custom.chatgetter.ChatGetter> . So if you have a message, you can access that too: # ChatGetter has a chat_id property, and Message bases ChatGetter. # Thus you can use ChatGetter properties and methods from Message print ( message . chat_id ) Telegram has a lot to offer, and inheritance helps the library reduce boilerplate, so it's important to know this concept. For newcomers, this may be a problem, so we explain what it means here in the FAQ.","title":"What does bases ChatGetter mean?"},{"location":"quick-references/faq/#can-i-use-flask-with-the-library","text":"Yes, if you know what you are doing. However, you will probably have a lot of headaches to get threads and asyncio to work together. Instead, consider using Quart , an asyncio-based alternative to Flask . Check out quart_login.py for an example web-application based on Quart.","title":"Can I use Flask with the library?"},{"location":"quick-references/faq/#can-i-use-anacondaspyderipython-with-the-library","text":"Yes, but these interpreters run the asyncio event loop implicitly, which interferes with the telethon.sync magic module. If you use them, you should not import sync : # Change any of these...: from telethon import TelegramClient , sync , ... from telethon.sync import TelegramClient , ... # ...with this: from telethon import TelegramClient , ... You are also more likely to get \"sqlite3.OperationalError: database is locked\" with them. If they cause too much trouble, just write your code in a .py file and run that, or use the normal python interpreter.","title":"Can I use Anaconda/Spyder/IPython with the library?"}]}