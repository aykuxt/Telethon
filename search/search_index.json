{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Telethon's Documentation \u00a4 from telethon.sync import TelegramClient , events with TelegramClient ( 'name' , api_id , api_hash ) as client : client . send_message ( 'me' , 'Hello, myself!' ) print ( client . download_profile_photo ( 'me' )) @client . on ( events . NewMessage ( pattern = '(?i).*Hello' )) async def handler ( event ): await event . reply ( 'Hey!' ) client . run_until_disconnected () Are you new here? Jump straight into Installation ! Looking for the method reference? See Client Reference . Did you upgrade the library? Please read Changelog (Version History) . Used Telethon before v1.0? See Compatibility and Convenience . Coming from Bot API or want to create new bots? See HTTP Bot API vs MTProto . Need the full API reference? https://tl.telethon.dev . What is this? \u00a4 Telegram is a popular messaging application. This library is meant to make it easy for you to write Python programs that can interact with Telegram. Think of it as a wrapper that has already done the heavy job for you, so you can focus on developing an application. How should I use the documentation? \u00a4 If you are getting started with the library, you should follow the documentation in order by pressing the \"Next\" button at the bottom-right of every page. You can also use the menu on the left to quickly skip over sections.","title":"Getting started"},{"location":"#telethons-documentation","text":"from telethon.sync import TelegramClient , events with TelegramClient ( 'name' , api_id , api_hash ) as client : client . send_message ( 'me' , 'Hello, myself!' ) print ( client . download_profile_photo ( 'me' )) @client . on ( events . NewMessage ( pattern = '(?i).*Hello' )) async def handler ( event ): await event . reply ( 'Hey!' ) client . run_until_disconnected () Are you new here? Jump straight into Installation ! Looking for the method reference? See Client Reference . Did you upgrade the library? Please read Changelog (Version History) . Used Telethon before v1.0? See Compatibility and Convenience . Coming from Bot API or want to create new bots? See HTTP Bot API vs MTProto . Need the full API reference? https://tl.telethon.dev .","title":"Telethon's Documentation"},{"location":"#what-is-this","text":"Telegram is a popular messaging application. This library is meant to make it easy for you to write Python programs that can interact with Telegram. Think of it as a wrapper that has already done the heavy job for you, so you can focus on developing an application.","title":"What is this?"},{"location":"#how-should-i-use-the-documentation","text":"If you are getting started with the library, you should follow the documentation in order by pressing the \"Next\" button at the bottom-right of every page. You can also use the menu on the left to quickly skip over sections.","title":"How should I use the documentation?"},{"location":"basic/installation/","text":"Installation \u00a4 Telethon is a Python library, which means you need to download and install Python from https://www.python.org/downloads/ if you haven't already. Once you have Python installed, run: pip3 install -U telethon --user To install or upgrade the library to the latest version. Installing Development Versions \u00a4 If you want the latest unreleased changes, you can run the following command instead: pip3 install -U https://github.com/LonamiWebs/Telethon/archive/master.zip --user Note The development version may have bugs and is not recommended for production use. However, when you are reporting a library bug , you should try if the bug still occurs in this version. Verification \u00a4 To verify that the library is installed correctly, run the following command: python3 -c \"import telethon; print(telethon.__version__)\" The version number of the library should show in the output. Optional Dependencies \u00a4 If cryptg is installed, the library will work a lot faster , since encryption and decryption will be made in C instead of Python. If your code deals with a lot of updates or you are downloading/uploading a lot of files, you will notice a considerable speed-up (from a hundred kilobytes per second to several megabytes per second, if your connection allows it). If it's not installed, pyaes will be used (which is pure Python, so it's much slower). If pillow is installed, large images will be automatically resized when sending photos to prevent Telegram from failing with \"invalid image\". Official clients also do this. If aiohttp is installed, the library will be able to download :tl: WebDocument media files (otherwise you will get an error). If hachoir is installed, it will be used to extract metadata from files when sending documents. Telegram uses this information to show the song's performer, artist, title, duration, and for videos too (including size). Otherwise, they will default to empty values, and you can set the attributes manually. Note Some of the modules may require additional dependencies before being installed through pip . If you have an apt -based system, consider installing the most commonly missing dependencies: apt update apt install clang lib { jpeg-turbo,webp } -dev python { ,-dev } zlib-dev pip install -U --user setuptools pip install -U --user telethon cryptg pillow Thanks to @bb010g for writing down this nice list.","title":"Installation"},{"location":"basic/installation/#installation","text":"Telethon is a Python library, which means you need to download and install Python from https://www.python.org/downloads/ if you haven't already. Once you have Python installed, run: pip3 install -U telethon --user To install or upgrade the library to the latest version.","title":"Installation"},{"location":"basic/installation/#installing-development-versions","text":"If you want the latest unreleased changes, you can run the following command instead: pip3 install -U https://github.com/LonamiWebs/Telethon/archive/master.zip --user Note The development version may have bugs and is not recommended for production use. However, when you are reporting a library bug , you should try if the bug still occurs in this version.","title":"Installing Development Versions"},{"location":"basic/installation/#verification","text":"To verify that the library is installed correctly, run the following command: python3 -c \"import telethon; print(telethon.__version__)\" The version number of the library should show in the output.","title":"Verification"},{"location":"basic/installation/#optional-dependencies","text":"If cryptg is installed, the library will work a lot faster , since encryption and decryption will be made in C instead of Python. If your code deals with a lot of updates or you are downloading/uploading a lot of files, you will notice a considerable speed-up (from a hundred kilobytes per second to several megabytes per second, if your connection allows it). If it's not installed, pyaes will be used (which is pure Python, so it's much slower). If pillow is installed, large images will be automatically resized when sending photos to prevent Telegram from failing with \"invalid image\". Official clients also do this. If aiohttp is installed, the library will be able to download :tl: WebDocument media files (otherwise you will get an error). If hachoir is installed, it will be used to extract metadata from files when sending documents. Telegram uses this information to show the song's performer, artist, title, duration, and for videos too (including size). Otherwise, they will default to empty values, and you can set the attributes manually. Note Some of the modules may require additional dependencies before being installed through pip . If you have an apt -based system, consider installing the most commonly missing dependencies: apt update apt install clang lib { jpeg-turbo,webp } -dev python { ,-dev } zlib-dev pip install -U --user setuptools pip install -U --user telethon cryptg pillow Thanks to @bb010g for writing down this nice list.","title":"Optional Dependencies"},{"location":"basic/next-steps/","text":"Next Steps \u00a4 These basic first steps should have gotten you started with the library. By now, you should know how to call friendly methods and how to work with the returned objects, how things work inside event handlers, etc. Next, we will see a quick reference summary of all the methods and properties that you will need when using the library. If you follow the links there, you will expand the documentation for the method and property, with more examples on how to use them. Therefore, you can find an example on every method of the client to learn how to use it, as well as a description of all the arguments. After that, we will go in-depth with some other important concepts that are worth learning and understanding. From now on, you can keep pressing the \"Next\" button if you want, or use the menu on the left, since some pages are quite lengthy.","title":"Next Steps"},{"location":"basic/next-steps/#next-steps","text":"These basic first steps should have gotten you started with the library. By now, you should know how to call friendly methods and how to work with the returned objects, how things work inside event handlers, etc. Next, we will see a quick reference summary of all the methods and properties that you will need when using the library. If you follow the links there, you will expand the documentation for the method and property, with more examples on how to use them. Therefore, you can find an example on every method of the client to learn how to use it, as well as a description of all the arguments. After that, we will go in-depth with some other important concepts that are worth learning and understanding. From now on, you can keep pressing the \"Next\" button if you want, or use the menu on the left, since some pages are quite lengthy.","title":"Next Steps"},{"location":"basic/quick-start/","text":"Quick-Start \u00a4 Let's see a longer example to learn some of the methods that the library has to offer. These are known as \"friendly methods\", and you should always use these if possible. from telethon import TelegramClient # Remember to use your own values from my.telegram.org! api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' client = TelegramClient ( 'anon' , api_id , api_hash ) async def main (): # Getting information about yourself me = await client . get_me () # \"me\" is an User object. You can pretty-print # any Telegram object with the \"stringify\" method: print ( me . stringify ()) # When you print something, you see a representation of it. # You can access all attributes of Telegram objects with # the dot operator. For example, to get the username: username = me . username print ( username ) print ( me . phone ) # You can print all the dialogs/conversations that you are part of: async for dialog in client . iter_dialogs (): print ( dialog . name , 'has ID' , dialog . id ) # You can send messages to yourself... await client . send_message ( 'me' , 'Hello, myself!' ) # ...to some chat ID await client . send_message ( - 100123456 , 'Hello, group!' ) # ...to your contacts await client . send_message ( '+34600123123' , 'Hello, friend!' ) # ...or even to any username await client . send_message ( 'TelethonChat' , 'Hello, Telethon!' ) # You can, of course, use markdown in your messages: message = await client . send_message ( 'me' , 'This message has **bold**, `code`, __italics__ and ' 'a [nice website](https://example.com)!' , link_preview = False ) # Sending a message returns the sent message object, which you can use print ( message . raw_text ) # You can reply to messages directly if you have a message object await message . reply ( 'Cool!' ) # Or send files, songs, documents, albums... await client . send_file ( 'me' , '/home/me/Pictures/holidays.jpg' ) # You can print the message history of any chat: async for message in client . iter_messages ( 'me' ): print ( message . id , message . text ) # You can download media from messages, too! # The method will return the path where the file was saved. if message . photo : path = await message . download_media () print ( 'File saved to' , path ) # printed after download is done with client : client . loop . run_until_complete ( main ()) Here, we show how to sign in, get information about yourself, send messages, files, getting chats, printing messages, and downloading files. You should make sure that you understand what the code shown here does, take note on how methods are called and used and so on before proceeding. We will see all the available methods later on. Important Note that Telethon is an asynchronous library, and as such, you should get used to it and learn a bit of basic asyncio . This will help a lot. As a quick start, this means you generally want to write all your code inside some async def like so: client = ... async def do_something ( me ): ... async def main (): # Most of your code should go here. # You can of course make and use your own async def (do_something). # They only need to be async if they need to await things. me = await client . get_me () await do_something ( me ) with client : client . loop . run_until_complete ( main ()) After you understand this, you may use the telethon.sync hack if you want do so (see :ref: compatibility-and-convenience ), but note you may run into other issues (iPython, Anaconda, etc. have some issues with it).","title":"Quick-Start"},{"location":"basic/quick-start/#quick-start","text":"Let's see a longer example to learn some of the methods that the library has to offer. These are known as \"friendly methods\", and you should always use these if possible. from telethon import TelegramClient # Remember to use your own values from my.telegram.org! api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' client = TelegramClient ( 'anon' , api_id , api_hash ) async def main (): # Getting information about yourself me = await client . get_me () # \"me\" is an User object. You can pretty-print # any Telegram object with the \"stringify\" method: print ( me . stringify ()) # When you print something, you see a representation of it. # You can access all attributes of Telegram objects with # the dot operator. For example, to get the username: username = me . username print ( username ) print ( me . phone ) # You can print all the dialogs/conversations that you are part of: async for dialog in client . iter_dialogs (): print ( dialog . name , 'has ID' , dialog . id ) # You can send messages to yourself... await client . send_message ( 'me' , 'Hello, myself!' ) # ...to some chat ID await client . send_message ( - 100123456 , 'Hello, group!' ) # ...to your contacts await client . send_message ( '+34600123123' , 'Hello, friend!' ) # ...or even to any username await client . send_message ( 'TelethonChat' , 'Hello, Telethon!' ) # You can, of course, use markdown in your messages: message = await client . send_message ( 'me' , 'This message has **bold**, `code`, __italics__ and ' 'a [nice website](https://example.com)!' , link_preview = False ) # Sending a message returns the sent message object, which you can use print ( message . raw_text ) # You can reply to messages directly if you have a message object await message . reply ( 'Cool!' ) # Or send files, songs, documents, albums... await client . send_file ( 'me' , '/home/me/Pictures/holidays.jpg' ) # You can print the message history of any chat: async for message in client . iter_messages ( 'me' ): print ( message . id , message . text ) # You can download media from messages, too! # The method will return the path where the file was saved. if message . photo : path = await message . download_media () print ( 'File saved to' , path ) # printed after download is done with client : client . loop . run_until_complete ( main ()) Here, we show how to sign in, get information about yourself, send messages, files, getting chats, printing messages, and downloading files. You should make sure that you understand what the code shown here does, take note on how methods are called and used and so on before proceeding. We will see all the available methods later on. Important Note that Telethon is an asynchronous library, and as such, you should get used to it and learn a bit of basic asyncio . This will help a lot. As a quick start, this means you generally want to write all your code inside some async def like so: client = ... async def do_something ( me ): ... async def main (): # Most of your code should go here. # You can of course make and use your own async def (do_something). # They only need to be async if they need to await things. me = await client . get_me () await do_something ( me ) with client : client . loop . run_until_complete ( main ()) After you understand this, you may use the telethon.sync hack if you want do so (see :ref: compatibility-and-convenience ), but note you may run into other issues (iPython, Anaconda, etc. have some issues with it).","title":"Quick-Start"},{"location":"basic/signing-in/","text":"Signing In \u00a4 Before working with Telegram's API, you need to get your own API ID and hash: Login to your Telegram account with the phone number of the developer account to use. Click under API Development tools. A Create new application window will appear. Fill in your application details. There is no need to enter any URL , and only the first two fields ( App title and Short name ) can currently be changed later. Click on Create application at the end. Remember that your API hash is secret and Telegram won't let you revoke it. Don't post it anywhere! Note This API ID and hash is the one used by your application , not your phone number. You can use this API ID and hash with any phone number or even for bot accounts. Editing the Code \u00a4 This is a little introduction for those new to Python programming in general. We will write our code inside hello.py , so you can use any text editor that you like. To run the code, use python3 hello.py from the terminal. Important Don't call your script telethon.py ! Python will try to import the client from there and it will fail with an error such as ImportError: cannot import name 'TelegramClient' ... . Signing In \u00a4 We can finally write some code to log into our account! from telethon import TelegramClient # Use your own values from my.telegram.org api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' # The first parameter is the .session file name (absolute paths allowed) with TelegramClient ( 'anon' , api_id , api_hash ) as client : client . loop . run_until_complete ( client . send_message ( 'me' , 'Hello, myself!' )) In the first line, we import the class name so we can create an instance of the client. Then, we define variables to store our API ID and hash conveniently. At last, we create a new TelegramClient <telethon.client.telegramclient.TelegramClient> instance and call it client . We can now use the client variable for anything that we want, such as sending a message to ourselves. Note Since Telethon is an asynchronous library, you need to await coroutine functions to have them run (or otherwise, run the loop until they are complete). In this tiny example, we don't bother making an async def main() . See :ref: mastering-asyncio to find out more. Using a with block is the preferred way to use the library. It will automatically start() <telethon.client.auth.AuthMethods.start> the client, logging or signing up if necessary. If the .session file already existed, it will not login again, so be aware of this if you move or rename the file! Signing In as a Bot Account \u00a4 You can also use Telethon for your bots (normal bot accounts, not users). You will still need an API ID and hash, but the process is very similar: from telethon.sync import TelegramClient api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' bot_token = '12345:0123456789abcdef0123456789abcdef' # We have to manually call \"start\" if we want an explicit bot token bot = TelegramClient ( 'bot' , api_id , api_hash ) . start ( bot_token = bot_token ) # But then we can use the client instance as usual with bot : ... To get a bot account, you need to talk with @BotFather <https://t.me/BotFather> _. Signing In behind a Proxy \u00a4 If you need to use a proxy to access Telegram, you will need to install PySocks and then change: TelegramClient ( 'anon' , api_id , api_hash ) with TelegramClient ( 'anon' , api_id , api_hash , proxy = ( socks . SOCKS5 , '127.0.0.1' , 4444 )) (of course, replacing the IP and port with the IP and port of the proxy). The proxy= argument should be a tuple, a list or a dict, consisting of parameters described in PySocks usage . Using MTProto Proxies \u00a4 MTProto Proxies are Telegram's alternative to normal proxies, and work a bit differently. The following protocols are available: ConnectionTcpMTProxyAbridged ConnectionTcpMTProxyIntermediate ConnectionTcpMTProxyRandomizedIntermediate (preferred) For now, you need to manually specify these special connection modes if you want to use a MTProto Proxy. Your code would look like this: from telethon import TelegramClient , connection # we need to change the connection ^^^^^^^^^^ client = TelegramClient ( 'anon' , api_id , api_hash , # Use one of the available connection modes. # Normally, this one works with most proxies. connection = connection . ConnectionTcpMTProxyRandomizedIntermediate , # Then, pass the proxy details as a tuple: # (host name, port, proxy secret) # # If the proxy has no secret, the secret must be: # '00000000000000000000000000000000' proxy = ( 'mtproxy.example.com' , 2002 , 'secret' ) ) In future updates, we may make it easier to use MTProto Proxies (such as avoiding the need to manually pass connection= ). In short, the same code above but without comments to make it clearer: from telethon import TelegramClient , connection client = TelegramClient ( 'anon' , api_id , api_hash , connection = connection . ConnectionTcpMTProxyRandomizedIntermediate , proxy = ( 'mtproxy.example.com' , 2002 , 'secret' ) )","title":"Signing In"},{"location":"basic/signing-in/#signing-in","text":"Before working with Telegram's API, you need to get your own API ID and hash: Login to your Telegram account with the phone number of the developer account to use. Click under API Development tools. A Create new application window will appear. Fill in your application details. There is no need to enter any URL , and only the first two fields ( App title and Short name ) can currently be changed later. Click on Create application at the end. Remember that your API hash is secret and Telegram won't let you revoke it. Don't post it anywhere! Note This API ID and hash is the one used by your application , not your phone number. You can use this API ID and hash with any phone number or even for bot accounts.","title":"Signing In"},{"location":"basic/signing-in/#editing-the-code","text":"This is a little introduction for those new to Python programming in general. We will write our code inside hello.py , so you can use any text editor that you like. To run the code, use python3 hello.py from the terminal. Important Don't call your script telethon.py ! Python will try to import the client from there and it will fail with an error such as ImportError: cannot import name 'TelegramClient' ... .","title":"Editing the Code"},{"location":"basic/signing-in/#signing-in_1","text":"We can finally write some code to log into our account! from telethon import TelegramClient # Use your own values from my.telegram.org api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' # The first parameter is the .session file name (absolute paths allowed) with TelegramClient ( 'anon' , api_id , api_hash ) as client : client . loop . run_until_complete ( client . send_message ( 'me' , 'Hello, myself!' )) In the first line, we import the class name so we can create an instance of the client. Then, we define variables to store our API ID and hash conveniently. At last, we create a new TelegramClient <telethon.client.telegramclient.TelegramClient> instance and call it client . We can now use the client variable for anything that we want, such as sending a message to ourselves. Note Since Telethon is an asynchronous library, you need to await coroutine functions to have them run (or otherwise, run the loop until they are complete). In this tiny example, we don't bother making an async def main() . See :ref: mastering-asyncio to find out more. Using a with block is the preferred way to use the library. It will automatically start() <telethon.client.auth.AuthMethods.start> the client, logging or signing up if necessary. If the .session file already existed, it will not login again, so be aware of this if you move or rename the file!","title":"Signing In"},{"location":"basic/signing-in/#signing-in-as-a-bot-account","text":"You can also use Telethon for your bots (normal bot accounts, not users). You will still need an API ID and hash, but the process is very similar: from telethon.sync import TelegramClient api_id = 12345 api_hash = '0123456789abcdef0123456789abcdef' bot_token = '12345:0123456789abcdef0123456789abcdef' # We have to manually call \"start\" if we want an explicit bot token bot = TelegramClient ( 'bot' , api_id , api_hash ) . start ( bot_token = bot_token ) # But then we can use the client instance as usual with bot : ... To get a bot account, you need to talk with @BotFather <https://t.me/BotFather> _.","title":"Signing In as a Bot Account"},{"location":"basic/signing-in/#signing-in-behind-a-proxy","text":"If you need to use a proxy to access Telegram, you will need to install PySocks and then change: TelegramClient ( 'anon' , api_id , api_hash ) with TelegramClient ( 'anon' , api_id , api_hash , proxy = ( socks . SOCKS5 , '127.0.0.1' , 4444 )) (of course, replacing the IP and port with the IP and port of the proxy). The proxy= argument should be a tuple, a list or a dict, consisting of parameters described in PySocks usage .","title":"Signing In behind a Proxy"},{"location":"basic/signing-in/#using-mtproto-proxies","text":"MTProto Proxies are Telegram's alternative to normal proxies, and work a bit differently. The following protocols are available: ConnectionTcpMTProxyAbridged ConnectionTcpMTProxyIntermediate ConnectionTcpMTProxyRandomizedIntermediate (preferred) For now, you need to manually specify these special connection modes if you want to use a MTProto Proxy. Your code would look like this: from telethon import TelegramClient , connection # we need to change the connection ^^^^^^^^^^ client = TelegramClient ( 'anon' , api_id , api_hash , # Use one of the available connection modes. # Normally, this one works with most proxies. connection = connection . ConnectionTcpMTProxyRandomizedIntermediate , # Then, pass the proxy details as a tuple: # (host name, port, proxy secret) # # If the proxy has no secret, the secret must be: # '00000000000000000000000000000000' proxy = ( 'mtproxy.example.com' , 2002 , 'secret' ) ) In future updates, we may make it easier to use MTProto Proxies (such as avoiding the need to manually pass connection= ). In short, the same code above but without comments to make it clearer: from telethon import TelegramClient , connection client = TelegramClient ( 'anon' , api_id , api_hash , connection = connection . ConnectionTcpMTProxyRandomizedIntermediate , proxy = ( 'mtproxy.example.com' , 2002 , 'secret' ) )","title":"Using MTProto Proxies"},{"location":"basic/updates/","text":"Updates \u00a4 Updates are an important topic in a messaging platform like Telegram. After all, you want to be notified when a new message arrives, when a member joins, when someone starts typing, etc. For that, you can use events . Important It is strongly advised to enable logging when working with events, since exceptions in event handlers are hidden by default. Please add the following snippet to the very top of your file: import logging logging . basicConfig ( format = '[ %(levelname) 5s / %(asctime)s ] %(name)s : %(message)s ' , level = logging . WARNING ) Getting Started \u00a4 Let's start things with an example to automate replies: from telethon import TelegramClient , events client = TelegramClient ( 'anon' , api_id , api_hash ) @client . on ( events . NewMessage ) async def my_event_handler ( event ): if 'hello' in event . raw_text : await event . reply ( 'hi!' ) client . start () client . run_until_disconnected () This code isn't much, but there might be some things unclear. Let's break it down: from telethon import TelegramClient , events client = TelegramClient ( 'anon' , api_id , api_hash ) This is normal creation (of course, pass session name, API ID and hash). Nothing we don't know already. @client . on ( events . NewMessage ) This Python decorator will attach itself to the my_event_handler definition, and basically means that on a NewMessage <telethon.events.newmessage.NewMessage> event , the callback function you're about to define will be called: async def my_event_handler ( event ): if 'hello' in event . raw_text : await event . reply ( 'hi!' ) If a NewMessage <telethon.events.newmessage.NewMessage> event occurs, and 'hello' is in the text of the message, we reply() <telethon.tl.custom.message.Message.reply> to the event with a 'hi!' message. Note Event handlers must be async def . After all, Telethon is an asynchronous library based on asyncio , which is a safer and often faster approach to threads. You must await all method calls that use network requests, which is most of them. More Examples \u00a4 Replying to messages with hello is fun, but, can we do more? @client . on ( events . NewMessage ( outgoing = True , pattern = r '\\.save' )) async def handler ( event ): if event . is_reply : replied = await event . get_reply_message () sender = replied . sender await client . download_profile_photo ( sender ) await event . respond ( 'Saved your photo {} ' . format ( sender . username )) We could also get replies. This event filters outgoing messages (only those that we send will trigger the method), then we filter by the regex r'\\.save' , which will match messages starting with \".save\" . Inside the method, we check whether the event is replying to another message or not. If it is, we get the reply message and the sender of that message, and download their profile photo. Let's delete messages which contain \"heck\". We don't allow swearing here. @client . on ( events . NewMessage ( pattern = r '(?i).*heck' )) async def handler ( event ): await event . delete () With the r'(?i).*heck' regex, we match case-insensitive \"heck\" anywhere in the message. Regex is very powerful and you can learn more at https://regexone.com/. So far, we have only seen the NewMessage <telethon.events.newmessage.NewMessage> , but there are many more which will be covered later. This is only a small introduction to updates. Entities \u00a4 When you need the user or chat where an event occurred, you must use the following methods: async def handler ( event ): # Good chat = await event . get_chat () sender = await event . get_sender () chat_id = event . chat_id sender_id = event . sender_id # BAD. Don't do this chat = event . chat sender = event . sender chat_id = event . chat . id sender_id = event . sender . id Events are like messages, but don't have all the information a message has! When you manually get a message, it will have all the information it needs. When you receive an update about a message, it won't have all the information, so you have to use the methods , not the properties. Make sure you understand the code seen here before continuing! As a rule of thumb, remember that new message events behave just like message objects, so you can do with them everything you can do with a message object.","title":"Updates"},{"location":"basic/updates/#updates","text":"Updates are an important topic in a messaging platform like Telegram. After all, you want to be notified when a new message arrives, when a member joins, when someone starts typing, etc. For that, you can use events . Important It is strongly advised to enable logging when working with events, since exceptions in event handlers are hidden by default. Please add the following snippet to the very top of your file: import logging logging . basicConfig ( format = '[ %(levelname) 5s / %(asctime)s ] %(name)s : %(message)s ' , level = logging . WARNING )","title":"Updates"},{"location":"basic/updates/#getting-started","text":"Let's start things with an example to automate replies: from telethon import TelegramClient , events client = TelegramClient ( 'anon' , api_id , api_hash ) @client . on ( events . NewMessage ) async def my_event_handler ( event ): if 'hello' in event . raw_text : await event . reply ( 'hi!' ) client . start () client . run_until_disconnected () This code isn't much, but there might be some things unclear. Let's break it down: from telethon import TelegramClient , events client = TelegramClient ( 'anon' , api_id , api_hash ) This is normal creation (of course, pass session name, API ID and hash). Nothing we don't know already. @client . on ( events . NewMessage ) This Python decorator will attach itself to the my_event_handler definition, and basically means that on a NewMessage <telethon.events.newmessage.NewMessage> event , the callback function you're about to define will be called: async def my_event_handler ( event ): if 'hello' in event . raw_text : await event . reply ( 'hi!' ) If a NewMessage <telethon.events.newmessage.NewMessage> event occurs, and 'hello' is in the text of the message, we reply() <telethon.tl.custom.message.Message.reply> to the event with a 'hi!' message. Note Event handlers must be async def . After all, Telethon is an asynchronous library based on asyncio , which is a safer and often faster approach to threads. You must await all method calls that use network requests, which is most of them.","title":"Getting Started"},{"location":"basic/updates/#more-examples","text":"Replying to messages with hello is fun, but, can we do more? @client . on ( events . NewMessage ( outgoing = True , pattern = r '\\.save' )) async def handler ( event ): if event . is_reply : replied = await event . get_reply_message () sender = replied . sender await client . download_profile_photo ( sender ) await event . respond ( 'Saved your photo {} ' . format ( sender . username )) We could also get replies. This event filters outgoing messages (only those that we send will trigger the method), then we filter by the regex r'\\.save' , which will match messages starting with \".save\" . Inside the method, we check whether the event is replying to another message or not. If it is, we get the reply message and the sender of that message, and download their profile photo. Let's delete messages which contain \"heck\". We don't allow swearing here. @client . on ( events . NewMessage ( pattern = r '(?i).*heck' )) async def handler ( event ): await event . delete () With the r'(?i).*heck' regex, we match case-insensitive \"heck\" anywhere in the message. Regex is very powerful and you can learn more at https://regexone.com/. So far, we have only seen the NewMessage <telethon.events.newmessage.NewMessage> , but there are many more which will be covered later. This is only a small introduction to updates.","title":"More Examples"},{"location":"basic/updates/#entities","text":"When you need the user or chat where an event occurred, you must use the following methods: async def handler ( event ): # Good chat = await event . get_chat () sender = await event . get_sender () chat_id = event . chat_id sender_id = event . sender_id # BAD. Don't do this chat = event . chat sender = event . sender chat_id = event . chat . id sender_id = event . sender . id Events are like messages, but don't have all the information a message has! When you manually get a message, it will have all the information it needs. When you receive an update about a message, it won't have all the information, so you have to use the methods , not the properties. Make sure you understand the code seen here before continuing! As a rule of thumb, remember that new message events behave just like message objects, so you can do with them everything you can do with a message object.","title":"Entities"},{"location":"modules/helpers/","text":"\u00a4 Various helpers not related to the Telegram API itself TotalList \u00a4 A list with an extra total property, which may not match its len since the total represents the total amount of items available somewhere else, not the items in this list . Examples: # Telethon returns these lists in some cases (for example, # only when a chunk is returned, but the \"total\" count # is available). result = await client . get_messages ( chat , limit = 10 ) print ( result . total ) # large number print ( len ( result )) # 10 print ( result [ 0 ]) # latest message for x in result : # show the 10 messages print ( x . text ) ensure_parent_dir_exists ( file_path ) \u00a4 Ensures that the parent directory exists Source code in telethon\\helpers.py 23 24 25 26 27 def ensure_parent_dir_exists ( file_path ): \"\"\"Ensures that the parent directory exists\"\"\" parent = os . path . dirname ( file_path ) if parent : os . makedirs ( parent , exist_ok = True ) generate_key_data_from_nonce ( server_nonce , new_nonce ) \u00a4 Generates the key data corresponding to the given nonce Source code in telethon\\helpers.py 207 208 209 210 211 212 213 214 215 216 217 def generate_key_data_from_nonce ( server_nonce , new_nonce ): \"\"\"Generates the key data corresponding to the given nonce\"\"\" server_nonce = server_nonce . to_bytes ( 16 , 'little' , signed = True ) new_nonce = new_nonce . to_bytes ( 32 , 'little' , signed = True ) hash1 = sha1 ( new_nonce + server_nonce ) . digest () hash2 = sha1 ( server_nonce + new_nonce ) . digest () hash3 = sha1 ( new_nonce + new_nonce ) . digest () key = hash1 + hash2 [: 12 ] iv = hash2 [ 12 : 20 ] + hash3 + new_nonce [: 4 ] return key , iv generate_random_long ( signed = True ) \u00a4 Generates a random long integer (8 bytes), which is optionally signed Source code in telethon\\helpers.py 18 19 20 def generate_random_long ( signed = True ): \"\"\"Generates a random long integer (8 bytes), which is optionally signed\"\"\" return int . from_bytes ( os . urandom ( 8 ), signed = signed , byteorder = 'little' ) retry_range ( retries ) \u00a4 Generates an integer sequence starting from 1. If retries is not a zero or a positive integer value, the sequence will be infinite, otherwise it will end at retries + 1 . Source code in telethon\\helpers.py 97 98 99 100 101 102 103 104 105 106 107 def retry_range ( retries ): \"\"\" Generates an integer sequence starting from 1. If `retries` is not a zero or a positive integer value, the sequence will be infinite, otherwise it will end at `retries + 1`. \"\"\" yield 1 attempt = 0 while attempt != retries : attempt += 1 yield 1 + attempt strip_text ( text , entities ) \u00a4 Strips whitespace from the given text modifying the provided entities. This assumes that there are no overlapping entities, that their length is greater or equal to one, and that their length is not out of bounds. Source code in telethon\\helpers.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def strip_text ( text , entities ): \"\"\" Strips whitespace from the given text modifying the provided entities. This assumes that there are no overlapping entities, that their length is greater or equal to one, and that their length is not out of bounds. \"\"\" if not entities : return text . strip () while text and text [ - 1 ] . isspace (): e = entities [ - 1 ] if e . offset + e . length == len ( text ): if e . length == 1 : del entities [ - 1 ] if not entities : return text . strip () else : e . length -= 1 text = text [: - 1 ] while text and text [ 0 ] . isspace (): for i in reversed ( range ( len ( entities ))): e = entities [ i ] if e . offset != 0 : e . offset -= 1 continue if e . length == 1 : del entities [ 0 ] if not entities : return text . lstrip () else : e . length -= 1 text = text [ 1 :] return text within_surrogate ( text , index , * , length = None ) \u00a4 True if index is within a surrogate (before and after it, not at!). Source code in telethon\\helpers.py 43 44 45 46 47 48 49 50 51 52 53 54 def within_surrogate ( text , index , * , length = None ): \"\"\" `True` if ``index`` is within a surrogate (before and after it, not at!). \"\"\" if length is None : length = len ( text ) return ( 1 < index < len ( text ) and # in bounds ' \\ud800 ' <= text [ index - 1 ] <= ' \\udfff ' and # previous is ' \\ud800 ' <= text [ index ] <= ' \\udfff ' # current is )","title":"Helpers"},{"location":"modules/helpers/#telethon.helpers","text":"Various helpers not related to the Telegram API itself","title":"telethon.helpers"},{"location":"modules/helpers/#telethon.helpers.TotalList","text":"A list with an extra total property, which may not match its len since the total represents the total amount of items available somewhere else, not the items in this list . Examples: # Telethon returns these lists in some cases (for example, # only when a chunk is returned, but the \"total\" count # is available). result = await client . get_messages ( chat , limit = 10 ) print ( result . total ) # large number print ( len ( result )) # 10 print ( result [ 0 ]) # latest message for x in result : # show the 10 messages print ( x . text )","title":"TotalList"},{"location":"modules/helpers/#telethon.helpers.ensure_parent_dir_exists","text":"Ensures that the parent directory exists Source code in telethon\\helpers.py 23 24 25 26 27 def ensure_parent_dir_exists ( file_path ): \"\"\"Ensures that the parent directory exists\"\"\" parent = os . path . dirname ( file_path ) if parent : os . makedirs ( parent , exist_ok = True )","title":"ensure_parent_dir_exists()"},{"location":"modules/helpers/#telethon.helpers.generate_key_data_from_nonce","text":"Generates the key data corresponding to the given nonce Source code in telethon\\helpers.py 207 208 209 210 211 212 213 214 215 216 217 def generate_key_data_from_nonce ( server_nonce , new_nonce ): \"\"\"Generates the key data corresponding to the given nonce\"\"\" server_nonce = server_nonce . to_bytes ( 16 , 'little' , signed = True ) new_nonce = new_nonce . to_bytes ( 32 , 'little' , signed = True ) hash1 = sha1 ( new_nonce + server_nonce ) . digest () hash2 = sha1 ( server_nonce + new_nonce ) . digest () hash3 = sha1 ( new_nonce + new_nonce ) . digest () key = hash1 + hash2 [: 12 ] iv = hash2 [ 12 : 20 ] + hash3 + new_nonce [: 4 ] return key , iv","title":"generate_key_data_from_nonce()"},{"location":"modules/helpers/#telethon.helpers.generate_random_long","text":"Generates a random long integer (8 bytes), which is optionally signed Source code in telethon\\helpers.py 18 19 20 def generate_random_long ( signed = True ): \"\"\"Generates a random long integer (8 bytes), which is optionally signed\"\"\" return int . from_bytes ( os . urandom ( 8 ), signed = signed , byteorder = 'little' )","title":"generate_random_long()"},{"location":"modules/helpers/#telethon.helpers.retry_range","text":"Generates an integer sequence starting from 1. If retries is not a zero or a positive integer value, the sequence will be infinite, otherwise it will end at retries + 1 . Source code in telethon\\helpers.py 97 98 99 100 101 102 103 104 105 106 107 def retry_range ( retries ): \"\"\" Generates an integer sequence starting from 1. If `retries` is not a zero or a positive integer value, the sequence will be infinite, otherwise it will end at `retries + 1`. \"\"\" yield 1 attempt = 0 while attempt != retries : attempt += 1 yield 1 + attempt","title":"retry_range()"},{"location":"modules/helpers/#telethon.helpers.strip_text","text":"Strips whitespace from the given text modifying the provided entities. This assumes that there are no overlapping entities, that their length is greater or equal to one, and that their length is not out of bounds. Source code in telethon\\helpers.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def strip_text ( text , entities ): \"\"\" Strips whitespace from the given text modifying the provided entities. This assumes that there are no overlapping entities, that their length is greater or equal to one, and that their length is not out of bounds. \"\"\" if not entities : return text . strip () while text and text [ - 1 ] . isspace (): e = entities [ - 1 ] if e . offset + e . length == len ( text ): if e . length == 1 : del entities [ - 1 ] if not entities : return text . strip () else : e . length -= 1 text = text [: - 1 ] while text and text [ 0 ] . isspace (): for i in reversed ( range ( len ( entities ))): e = entities [ i ] if e . offset != 0 : e . offset -= 1 continue if e . length == 1 : del entities [ 0 ] if not entities : return text . lstrip () else : e . length -= 1 text = text [ 1 :] return text","title":"strip_text()"},{"location":"modules/helpers/#telethon.helpers.within_surrogate","text":"True if index is within a surrogate (before and after it, not at!). Source code in telethon\\helpers.py 43 44 45 46 47 48 49 50 51 52 53 54 def within_surrogate ( text , index , * , length = None ): \"\"\" `True` if ``index`` is within a surrogate (before and after it, not at!). \"\"\" if length is None : length = len ( text ) return ( 1 < index < len ( text ) and # in bounds ' \\ud800 ' <= text [ index - 1 ] <= ' \\udfff ' and # previous is ' \\ud800 ' <= text [ index ] <= ' \\udfff ' # current is )","title":"within_surrogate()"},{"location":"quick-references/client-reference/","text":"Client Reference \u00a4 This page contains a summary of all the important methods and properties that you may need when using Telethon. They are sorted by relevance and are not in alphabetical order. You should use this page to learn about which methods are available, and if you need an usage example or further description of the arguments, be sure to follow the links. TelegramClient \u00a4 This is a summary of the methods and properties you will find at :ref: telethon-client . Auth \u00a4 .. currentmodule:: telethon.client.auth.AuthMethods .. autosummary:: :nosignatures: start send_code_request sign_in sign_up log_out edit_2fa Base \u00a4 .. py:currentmodule:: telethon.client.telegrambaseclient.TelegramBaseClient .. autosummary:: :nosignatures: connect disconnect is_connected disconnected loop Messages \u00a4 .. py:currentmodule:: telethon.client.messages.MessageMethods .. autosummary:: :nosignatures: send_message edit_message delete_messages forward_messages iter_messages get_messages pin_message send_read_acknowledge Uploads \u00a4 .. py:currentmodule:: telethon.client.uploads.UploadMethods .. autosummary:: :nosignatures: send_file upload_file Downloads \u00a4 .. currentmodule:: telethon.client.downloads.DownloadMethods .. autosummary:: :nosignatures: download_media download_profile_photo download_file iter_download Dialogs \u00a4 .. py:currentmodule:: telethon.client.dialogs.DialogMethods .. autosummary:: :nosignatures: iter_dialogs get_dialogs edit_folder iter_drafts get_drafts delete_dialog conversation Users \u00a4 .. py:currentmodule:: telethon.client.users.UserMethods .. autosummary:: :nosignatures: get_me is_bot is_user_authorized get_entity get_input_entity get_peer_id Chats \u00a4 .. currentmodule:: telethon.client.chats.ChatMethods .. autosummary:: :nosignatures: iter_participants get_participants kick_participant iter_admin_log get_admin_log iter_profile_photos get_profile_photos edit_admin edit_permissions action Parse Mode \u00a4 .. py:currentmodule:: telethon.client.messageparse.MessageParseMethods .. autosummary:: :nosignatures: parse_mode Updates \u00a4 .. py:currentmodule:: telethon.client.updates.UpdateMethods .. autosummary:: :nosignatures: on run_until_disconnected add_event_handler remove_event_handler list_event_handlers catch_up Bots \u00a4 .. currentmodule:: telethon.client.bots.BotMethods .. autosummary:: :nosignatures: inline_query Buttons \u00a4 .. currentmodule:: telethon.client.buttons.ButtonMethods .. autosummary:: :nosignatures: build_reply_markup Account \u00a4 .. currentmodule:: telethon.client.account.AccountMethods .. autosummary:: :nosignatures: takeout end_takeout","title":"Client Reference"},{"location":"quick-references/client-reference/#client-reference","text":"This page contains a summary of all the important methods and properties that you may need when using Telethon. They are sorted by relevance and are not in alphabetical order. You should use this page to learn about which methods are available, and if you need an usage example or further description of the arguments, be sure to follow the links.","title":"Client Reference"},{"location":"quick-references/client-reference/#telegramclient","text":"This is a summary of the methods and properties you will find at :ref: telethon-client .","title":"TelegramClient"},{"location":"quick-references/client-reference/#auth","text":".. currentmodule:: telethon.client.auth.AuthMethods .. autosummary:: :nosignatures: start send_code_request sign_in sign_up log_out edit_2fa","title":"Auth"},{"location":"quick-references/client-reference/#base","text":".. py:currentmodule:: telethon.client.telegrambaseclient.TelegramBaseClient .. autosummary:: :nosignatures: connect disconnect is_connected disconnected loop","title":"Base"},{"location":"quick-references/client-reference/#messages","text":".. py:currentmodule:: telethon.client.messages.MessageMethods .. autosummary:: :nosignatures: send_message edit_message delete_messages forward_messages iter_messages get_messages pin_message send_read_acknowledge","title":"Messages"},{"location":"quick-references/client-reference/#uploads","text":".. py:currentmodule:: telethon.client.uploads.UploadMethods .. autosummary:: :nosignatures: send_file upload_file","title":"Uploads"},{"location":"quick-references/client-reference/#downloads","text":".. currentmodule:: telethon.client.downloads.DownloadMethods .. autosummary:: :nosignatures: download_media download_profile_photo download_file iter_download","title":"Downloads"},{"location":"quick-references/client-reference/#dialogs","text":".. py:currentmodule:: telethon.client.dialogs.DialogMethods .. autosummary:: :nosignatures: iter_dialogs get_dialogs edit_folder iter_drafts get_drafts delete_dialog conversation","title":"Dialogs"},{"location":"quick-references/client-reference/#users","text":".. py:currentmodule:: telethon.client.users.UserMethods .. autosummary:: :nosignatures: get_me is_bot is_user_authorized get_entity get_input_entity get_peer_id","title":"Users"},{"location":"quick-references/client-reference/#chats","text":".. currentmodule:: telethon.client.chats.ChatMethods .. autosummary:: :nosignatures: iter_participants get_participants kick_participant iter_admin_log get_admin_log iter_profile_photos get_profile_photos edit_admin edit_permissions action","title":"Chats"},{"location":"quick-references/client-reference/#parse-mode","text":".. py:currentmodule:: telethon.client.messageparse.MessageParseMethods .. autosummary:: :nosignatures: parse_mode","title":"Parse Mode"},{"location":"quick-references/client-reference/#updates","text":".. py:currentmodule:: telethon.client.updates.UpdateMethods .. autosummary:: :nosignatures: on run_until_disconnected add_event_handler remove_event_handler list_event_handlers catch_up","title":"Updates"},{"location":"quick-references/client-reference/#bots","text":".. currentmodule:: telethon.client.bots.BotMethods .. autosummary:: :nosignatures: inline_query","title":"Bots"},{"location":"quick-references/client-reference/#buttons","text":".. currentmodule:: telethon.client.buttons.ButtonMethods .. autosummary:: :nosignatures: build_reply_markup","title":"Buttons"},{"location":"quick-references/client-reference/#account","text":".. currentmodule:: telethon.client.account.AccountMethods .. autosummary:: :nosignatures: takeout end_takeout","title":"Account"},{"location":"quick-references/faq/","text":"FAQ \u00a4 Let's start the quick references section with some useful tips to keep in mind, with the hope that you will understand why certain things work the way that they do. Code without errors doesn't work \u00a4 Then it probably has errors, but you haven't enabled logging yet. To enable logging, at the following code to the top of your main file: import logging logging . basicConfig ( format = '[ %(levelname) 5s / %(asctime)s ] %(name)s : %(message)s ' , level = logging . WARNING ) You can change the logging level to be something different, from less to more information: level = logging . CRITICAL # won't show errors (same as disabled) level = logging . ERROR # will only show errors that you didn't handle level = logging . WARNING # will also show messages with medium severity, such as internal Telegram issues level = logging . INFO # will also show informational messages, such as connection or disconnections level = logging . DEBUG # will show a lot of output to help debugging issues in the library See the official Python documentation for more information on logging_. How can I except FloodWaitError? \u00a4 You can use all errors from the API by importing: from telethon import errors And except them as such: try : await client . send_message ( chat , 'Hi' ) except errors . FloodWaitError as e : # e.seconds is how many seconds you have # to wait before making the request again. print ( 'Flood for' , e . seconds ) My account was deleted/limited when using the library \u00a4 The library will only do things that you tell it to do. If you use the library with bad intentions, Telegram will hopefully ban you. However, you may also be part of a limited country, such as Iran or Russia. In that case, we have bad news for you. Telegram is much more likely to ban these numbers, as they are often used to spam other accounts, likely through the use of libraries like this one. The best advice we can give you is to not abuse the API, like calling many requests really quickly, and to sign up with these phones through an official application. We have also had reports from Kazakhstan and China, where connecting would fail. To solve these connection problems, you should use a proxy. Telegram may also ban virtual (VoIP) phone numbers, as again, they're likely to be used for spam. If you want to check if your account has been limited, simply send a private message to @SpamBot through Telegram itself. You should notice this by getting errors like PeerFloodError , which means you're limited, for instance, when sending a message to some accounts but not others. For more discussion, please see issue 297 . How can I use a proxy? \u00a4 This was one of the first things described in :ref: signing-in . How do I access a field? \u00a4 This is basic Python knowledge. You should use the dot operator: me = await client . get_me () print ( me . username ) # ^ we used the dot operator to access the username attribute result = await client ( functions . photos . GetUserPhotosRequest ( user_id = 'me' , offset = 0 , max_id = 0 , limit = 100 )) # Working with list is also pretty basic print ( result . photos [ 0 ] . sizes [ - 1 ] . type ) # ^ ^ ^ ^ ^ # | | | | \\ type # | | | \\ last size # | | \\ list of sizes # access | \\ first photo from the list # the... \\ list of photos # # To print all, you could do (or mix-and-match): for photo in result . photos : for size in photo . sizes : print ( size . type ) AttributeError: 'coroutine' object has no attribute 'id' \u00a4 You either forgot to: import telethon.sync # ^^^^^ import sync Or: async def handler ( event ): me = await client . get_me () # ^^^^^ note the await print ( me . username ) sqlite3.OperationalError: database is locked \u00a4 An older process is still running and is using the same 'session' file. This error occurs when two or more clients use the same session , that is, when you write the same session name to be used in the client: You have an older process using the same session file. You have two different scripts running (interactive sessions count too). You have two clients in the same script running at the same time. The solution is, if you need two clients, use two sessions. If the problem persists and you're on Linux, you can use fuser my.session to find out the process locking the file. As a last resort, you can reboot your system. If you really dislike SQLite, use a different session storage. There is an entire section covering that at :ref: sessions . event.chat or event.sender is None \u00a4 Telegram doesn't always send this information in order to save bandwidth. If you need the information, you should fetch it yourself, since the library won't do unnecessary work unless you need to: async def handler ( event ): chat = await event . get_chat () sender = await event . get_sender () What does bases ChatGetter mean? \u00a4 In Python, classes can base others. This is called inheritance <https://ddg.gg/python%20inheritance> _. What it means is that \"if a class bases another, you can use the other's methods too\". For example, Message <telethon.tl.custom.message.Message> bases ChatGetter <telethon.tl.custom.chatgetter.ChatGetter> . In turn, ChatGetter <telethon.tl.custom.chatgetter.ChatGetter> defines things like obj.chat_id <telethon.tl.custom.chatgetter.ChatGetter> . So if you have a message, you can access that too: # ChatGetter has a chat_id property, and Message bases ChatGetter. # Thus you can use ChatGetter properties and methods from Message print ( message . chat_id ) Telegram has a lot to offer, and inheritance helps the library reduce boilerplate, so it's important to know this concept. For newcomers, this may be a problem, so we explain what it means here in the FAQ. Can I use Flask with the library? \u00a4 Yes, if you know what you are doing. However, you will probably have a lot of headaches to get threads and asyncio to work together. Instead, consider using Quart , an asyncio-based alternative to Flask . Check out quart_login.py for an example web-application based on Quart. Can I use Anaconda/Spyder/IPython with the library? \u00a4 Yes, but these interpreters run the asyncio event loop implicitly, which interferes with the telethon.sync magic module. If you use them, you should not import sync : # Change any of these...: from telethon import TelegramClient , sync , ... from telethon.sync import TelegramClient , ... # ...with this: from telethon import TelegramClient , ... You are also more likely to get \"sqlite3.OperationalError: database is locked\" with them. If they cause too much trouble, just write your code in a .py file and run that, or use the normal python interpreter.","title":"FAQ"},{"location":"quick-references/faq/#faq","text":"Let's start the quick references section with some useful tips to keep in mind, with the hope that you will understand why certain things work the way that they do.","title":"FAQ"},{"location":"quick-references/faq/#code-without-errors-doesnt-work","text":"Then it probably has errors, but you haven't enabled logging yet. To enable logging, at the following code to the top of your main file: import logging logging . basicConfig ( format = '[ %(levelname) 5s / %(asctime)s ] %(name)s : %(message)s ' , level = logging . WARNING ) You can change the logging level to be something different, from less to more information: level = logging . CRITICAL # won't show errors (same as disabled) level = logging . ERROR # will only show errors that you didn't handle level = logging . WARNING # will also show messages with medium severity, such as internal Telegram issues level = logging . INFO # will also show informational messages, such as connection or disconnections level = logging . DEBUG # will show a lot of output to help debugging issues in the library See the official Python documentation for more information on logging_.","title":"Code without errors doesn't work"},{"location":"quick-references/faq/#how-can-i-except-floodwaiterror","text":"You can use all errors from the API by importing: from telethon import errors And except them as such: try : await client . send_message ( chat , 'Hi' ) except errors . FloodWaitError as e : # e.seconds is how many seconds you have # to wait before making the request again. print ( 'Flood for' , e . seconds )","title":"How can I except FloodWaitError?"},{"location":"quick-references/faq/#my-account-was-deletedlimited-when-using-the-library","text":"The library will only do things that you tell it to do. If you use the library with bad intentions, Telegram will hopefully ban you. However, you may also be part of a limited country, such as Iran or Russia. In that case, we have bad news for you. Telegram is much more likely to ban these numbers, as they are often used to spam other accounts, likely through the use of libraries like this one. The best advice we can give you is to not abuse the API, like calling many requests really quickly, and to sign up with these phones through an official application. We have also had reports from Kazakhstan and China, where connecting would fail. To solve these connection problems, you should use a proxy. Telegram may also ban virtual (VoIP) phone numbers, as again, they're likely to be used for spam. If you want to check if your account has been limited, simply send a private message to @SpamBot through Telegram itself. You should notice this by getting errors like PeerFloodError , which means you're limited, for instance, when sending a message to some accounts but not others. For more discussion, please see issue 297 .","title":"My account was deleted/limited when using the library"},{"location":"quick-references/faq/#how-can-i-use-a-proxy","text":"This was one of the first things described in :ref: signing-in .","title":"How can I use a proxy?"},{"location":"quick-references/faq/#how-do-i-access-a-field","text":"This is basic Python knowledge. You should use the dot operator: me = await client . get_me () print ( me . username ) # ^ we used the dot operator to access the username attribute result = await client ( functions . photos . GetUserPhotosRequest ( user_id = 'me' , offset = 0 , max_id = 0 , limit = 100 )) # Working with list is also pretty basic print ( result . photos [ 0 ] . sizes [ - 1 ] . type ) # ^ ^ ^ ^ ^ # | | | | \\ type # | | | \\ last size # | | \\ list of sizes # access | \\ first photo from the list # the... \\ list of photos # # To print all, you could do (or mix-and-match): for photo in result . photos : for size in photo . sizes : print ( size . type )","title":"How do I access a field?"},{"location":"quick-references/faq/#attributeerror-coroutine-object-has-no-attribute-id","text":"You either forgot to: import telethon.sync # ^^^^^ import sync Or: async def handler ( event ): me = await client . get_me () # ^^^^^ note the await print ( me . username )","title":"AttributeError: 'coroutine' object has no attribute 'id'"},{"location":"quick-references/faq/#sqlite3operationalerror-database-is-locked","text":"An older process is still running and is using the same 'session' file. This error occurs when two or more clients use the same session , that is, when you write the same session name to be used in the client: You have an older process using the same session file. You have two different scripts running (interactive sessions count too). You have two clients in the same script running at the same time. The solution is, if you need two clients, use two sessions. If the problem persists and you're on Linux, you can use fuser my.session to find out the process locking the file. As a last resort, you can reboot your system. If you really dislike SQLite, use a different session storage. There is an entire section covering that at :ref: sessions .","title":"sqlite3.OperationalError: database is locked"},{"location":"quick-references/faq/#eventchat-or-eventsender-is-none","text":"Telegram doesn't always send this information in order to save bandwidth. If you need the information, you should fetch it yourself, since the library won't do unnecessary work unless you need to: async def handler ( event ): chat = await event . get_chat () sender = await event . get_sender ()","title":"event.chat or event.sender is None"},{"location":"quick-references/faq/#what-does-bases-chatgetter-mean","text":"In Python, classes can base others. This is called inheritance <https://ddg.gg/python%20inheritance> _. What it means is that \"if a class bases another, you can use the other's methods too\". For example, Message <telethon.tl.custom.message.Message> bases ChatGetter <telethon.tl.custom.chatgetter.ChatGetter> . In turn, ChatGetter <telethon.tl.custom.chatgetter.ChatGetter> defines things like obj.chat_id <telethon.tl.custom.chatgetter.ChatGetter> . So if you have a message, you can access that too: # ChatGetter has a chat_id property, and Message bases ChatGetter. # Thus you can use ChatGetter properties and methods from Message print ( message . chat_id ) Telegram has a lot to offer, and inheritance helps the library reduce boilerplate, so it's important to know this concept. For newcomers, this may be a problem, so we explain what it means here in the FAQ.","title":"What does bases ChatGetter mean?"},{"location":"quick-references/faq/#can-i-use-flask-with-the-library","text":"Yes, if you know what you are doing. However, you will probably have a lot of headaches to get threads and asyncio to work together. Instead, consider using Quart , an asyncio-based alternative to Flask . Check out quart_login.py for an example web-application based on Quart.","title":"Can I use Flask with the library?"},{"location":"quick-references/faq/#can-i-use-anacondaspyderipython-with-the-library","text":"Yes, but these interpreters run the asyncio event loop implicitly, which interferes with the telethon.sync magic module. If you use them, you should not import sync : # Change any of these...: from telethon import TelegramClient , sync , ... from telethon.sync import TelegramClient , ... # ...with this: from telethon import TelegramClient , ... You are also more likely to get \"sqlite3.OperationalError: database is locked\" with them. If they cause too much trouble, just write your code in a .py file and run that, or use the normal python interpreter.","title":"Can I use Anaconda/Spyder/IPython with the library?"}]}